<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>GoldWave Plug-in Interface</title>
<style type="text/css">
div.in { margin-left:40px }
dt {font-weight:bold; background-color:#E8E8E8; color:black}
code { background-color:#F0F0F0 }

/* Edit or delete the following 4 lines to remove colour from section headers */
h1 { text-align:center; background-color:#D0FFD0; color:black; margin:60px 0px 20px 0px; padding:7px 0px 7px 0px }
h2 { text-align:center; background-color:#A0D0FF; color:black; margin:40px 0px 20px 0px; padding:5px 0px 5px 0px }
h3 { text-align:left; background-color:#FFFFD0; color:black; margin:40px 0px 20px 0px; padding:2px 5px 2px 5px }
h4 { text-align:left; background-color:#E0E0E0; color:black; margin:40px 0px 20px 0px; padding:2px 5px 2px 5px }

</style>
</head>

<body style="background-color:white; color:black">

<h1 style="text-align:center;background-color:white;color:black">GoldWave Plug-in Interface</h1>
<p>
<p align="center">Copyright &copy; 2009 GoldWave&reg; Inc.
<p align="center">v3.01
<p>

<hr>
<h1>Table of Contents</h1>

<OL type="I">
<LI><b><a href="#Introduction">Introduction</a></b><br>
	<OL type="1">
		<LI><a href="#New">What's New</a>
		<LI><a href="#Overview">Overview</a>
		<LI><a href="#Plug-in Classes">Plug-in Classes</a>
	</OL>
<LI><b><a href="#Common Foundation">Common Foundation</a></b><br>
	<OL type="1">
		<LI><a href="#Host Program Interface">Host Program Interface</a>
			<OL type="a">
			<LI><a href="#Interface Function">Interface Function</a>
			<LI><a href="#Interface Structure">Interface Structure</a>
			<LI><a href="#Plug-in Table">Plug-in Table</a>
				<OL type="i">
				<LI><a href="#Plug-in Table Effect">Effect Table</a>
				<LI><a href="#Plug-in Table File Format">File Format Table</a>
				<LI><a href="#Plug-in Table Visual">Visual Table</a>
				</OL>
			<LI><a href="#Plug-in Creator Function">Plug-in Creator Function</a>
			<LI><a href="#Module Configuration">Module Configuration</a>
			</OL>
		<LI><a href="#PluginObject">PluginObject</a>
			<OL type="a">
			<LI><a href="#Page">Page</a>
			<LI><a href="#ConfigRead and ConfigWrite">ConfigRead and ConfigWrite</a>
			</OL>
		<LI><a href="#audio Type">audio Type</a>
		<LI><a href="#Error Codes">Error Codes</a>
	</OL>

<LI><b><a href="#Effect Plug-ins">Effect Plug-ins</a></b><br>
	<OL type="1">
		<LI><a href="#Transform Class">Transform Class</a>
		<LI><a href="#Effect Class">Effect Class</a>
		<LI><a href="#Source">Source</a>
		<LI><a href="#Effect::Read">Read</a>
		<OL type="a">
			<LI><a href="#Requested Samples">Requested Samples</a>
			<LI><a href="#Modifying Channels">Modifying Channels</a>
			<LI><a href="#Read Multithreading">Multithreading</a>
		</OL>
		<LI><a href="#Clipboard">Clipboard</a>
		<LI><a href="#Progress Class">Progress Class</a>
		<LI><a href="#Effect::Scan">Scan</a>
		<LI><a href="#Effect Host Program Usage">Host Program Usage</a>
	</OL>

<LI><b><a href="#File Format Plug-ins">File Format Plug-ins</a></b><br>
	<OL type="1">
		<LI><a href="#AudioFile Class">AudioFile Class</a>
		<LI><a href="#Format Class">Format Class</a>
		<LI><a href="#List Class">List Class</a>
		<LI><a href="#FormatList Class">FormatList Class</a>
		<LI><a href="#Metadata Class">Metadata Class</a>
		<OL type="a">
			<LI><a href="#Metadata Data Class">Data Class</a>
			<LI><a href="#Metadata Text Class">Text Class</a>
			<LI><a href="#Metadata CueList Class">CueList Class</a>
			<LI><a href="#Metadata PictureList Class">PictureList Class</a>
			<LI><a href="#Metadata Raw Class">Raw Class</a>
		</OL>
		<LI><a href="#Asker Class">Asker Class</a>
		<LI><a href="#File Format Reading">Reading</a>
		<OL type="a">
			<LI><a href="#AudioFile::Open">Open</a>
			<LI><a href="#AudioFile::Read">Read</a>
			<LI><a href="#AudioFile::Seek">Seek</a>
			<LI><a href="#AudioFile::Close">Close</a>
		</OL>

		<LI><a href="#File Format Writing">Writing</a>
		<OL type="a">
			<LI><a href="#AudioFile::Begin">Begin</a>
			<LI><a href="#AudioFile::Write">Write</a>
			<LI><a href="#AudioFile::End">End</a>
		</OL>

		<LI><a href="#File Format Management">Format Management</a>
		<OL type="a">
			<LI><a href="#AudioFile::GetFormat">GetFormat</a>
			<LI><a href="#AudioFile::Formats">Formats</a>
		</OL>

		<LI><a href="#Audio Host Program Usage">Host Program Usage</a>
		<OL type="a">
			<LI><a href="#Audio Host Reading">Reading</a>
			<LI><a href="#Audio Host Writing">Writing</a>
			<LI><a href="#Audio Host Format">Format Usage</a>
		</OL>
	</OL>

<LI><b><a href="#Visual Plug-ins">Visual Plug-ins</a></b><br>
	<OL type="1">
		<LI><a href="#State Structure">State Structure</a>
		<LI><a href="#Visual Class">Visual Class</a>
		<LI><a href="#Pixel Structure">Pixel Structure</a>
		<LI><a href="#DrawInfo Structure">DrawInfo Structure</a>
		<LI><a href="#EventInfo Structure">EventInfo Structure</a>
		<LI><a href="#Visual::SetState">SetState</a>
		<LI><a href="#Visual::Draw">Draw</a>
		<LI><a href="#Visual::Event">Event</a>
		<LI><a href="#Visual Host Program Usage">Host Program Usage</a>
	</OL>

<LI><b><a href="#Building">Compiling, Installing, and Testing</a></b><br>
	<OL type="1">
		<LI><a href="#Compiling">Compiling</a>
		<LI><a href="#Installing">Installing</a>
		<LI><a href="#Testing">Testing</a>
		<OL type="a">
			<LI><a href="#Effect Testing">Effect Testing</a>
			<LI><a href="#File Format Testing">File Format Testing</a>
			<LI><a href="#Visual Testing">Visual Testing</a>
		</OL>
	</OL>

<LI><b><a href="#Simplified Plug-ins">Simplified Plug-in SDK (Incomplete)</a></b><br>
	<OL>
		<LI><a href="#Simple Common Functions">Common Functions and Structures</a>
			<OL type="a">
				<LI><a href="#Simple Plug-in Functions">Plug-in Functions</a>
				<LI><a href="#Simple Page Functions">Page Functions</a>
				<LI><a href="#Simple Metadata Structure">Metadata Structure</a>
			</OL>
		<LI><a href="#Simple Visual Plug-ins">Simple Visual Plug-ins</a>
			<OL type="a">
				<LI><a href="#Simple Visual State Structure">State Structure</a>
				<LI><a href="#Simple Pixel Structure">Pixel Structure</a>
				<LI><a href="#Simple DrawInfo Structure">DrawInfo Structure</a>
				<LI><a href="#Simple EventInfo Structure">EventInfo Structure</a>
				<LI><a href="#Simple Visual Functions">Simple Visual Functions</a>
				<LI><a href="#Simple Visual Deployment">Simple Visual Deployment</a>
				<LI><a href="#Simple Visual Example">Simple Visual Example</a>
			</OL>
	</OL>

<LI><b><a href="#Tutorial">Tutorial</a></b><br>
	<OL type="1">
		<LI><a href="#Header Files, Namespace, and Entry Point">Header Files, Namespace, and Entry Point</a>
		<LI><a href="#Defining the Host Program Interface">Defining the Host Program Interface</a>
		<LI><a href="#Deriving the Plug-in Object">Deriving the Plug-in Object</a>
		<LI><a href="#Additional Examples">Additional Examples</a>
	</OL>

<LI><b><a href="#License">License</a></b><br>

<LI><b><a href="#FAQ">Frequently Asked Questions</a></b><br>
<LI><b><a href="#Glossary">Glossary</a></b><br>
</OL>
<P>

<h1><a name="Introduction">Introduction</a></h1>

<p>This document contains detailed information about the GoldWave Plug-in
Interface and describes now to create plug-ins for use in GoldWave
or other compatible host programs.

<h2><a name="New">What's New</a></h2>
<p>Several changes have been made that affect compatibility.  Therefore the version number
has been changed to v2.0.  Older plug-ins will not work in versions of GoldWave prior to v5.50 and
must be upgraded and recompiled.  The changes are as follows:

<ul>
<li>Plug-ins now use wide character strings for better international support, so <code>wchar_t</code>
replaces <code>char</code> for all functions.
<li>Visuals receive twice as much waveform and frequency data.
<li>Visual pixels are true colour, 32-bit ARGB.
<li>Some additions have been made for basic video handling.
</ul>

<h2><a name="Overview">Overview</a></h2>

<p>Plug-ins are external modules that programs use to add or
improve functionality.  Programs that use plug-ins are
called <i>host programs</i>.  They interacts with plug-in modules
through a <i>plug-in interface</i> as shown.

<p>
<center>
<img src="overview.png" alt="Plug-in Overview"><br>
Figure: Plug-in Overview
</center>

<p>The GoldWave <a href="#Plug-in">Plug-in</a> Interface contained in this
document makes it possible to add functionality
to GoldWave or other compatible <a href="#Host Program">host audio programs</a>
for handling new file formats, processing new effects,
or displaying new visuals.  The interface is entirely
self contained and does not depend on other libraries, APIs,
or development tools.  Unlike the DirectX Audio Plug-in
(DirectShow) interface, which potential requires advanced knowledge of
COM, Windows, and DirectX in addition to the plug-in interface
itself, the GoldWave Plug-in Interface requires knowledge of C++
only and is contained within a few header files.

<p>The interface is designed to be simple, portable,
open, and flexible.  It is very easy to implement
trivial plug-ins.  One can be created in a single file
with as little as two structures, one derived class, and
about 6 small functions.  See the <b>Mute.cpp</b> example
for details.

<h2><a name="Plug-in Classes">Plug-in Classes</a></h2>

<p>The GoldWave plug-in interface is divided into three separate,
but similar, plug-in classes: the File Format plug-in,
the Effect plug-in, and the Visual plug-in.  The figure
illustrates these classes.
A single plug-in module can have several plug-ins of
the same class.  For example, a developer can make a single
plug-in module to handle several different file formats or
a single plug-in module with several different effects.

<p>
<center>
<img src="pluginclasses.png" alt="Plug-in Classes"><br>
Figure: Plug-in Classes
</center>

<p>GoldWave already uses these plug-in interfaces
internally for most of its functionality.  All of the file handling and visuals
are implemented through the File Format and Visual plug-in interfaces.
With the exception of the Resample and Playback Rate effects,
all of the effects are implemented through the Effect plug-in interface.

<p>All of the plug-in classes have a similar, overlapping design.
The common features in all plug-in classes are discussed next.

<h1><a name="Common Foundation">Common Foundation</a></h1>

<p>The plug-in interface is composed of two parts: a
<a href="#Host Program">host program</a> interface,
and one or more derived plug-in objects.
This section explains these parts in detail.

<h2><a name="Host Program Interface">Host Program Interface</a></h2>

<p>The host program interface consists of a function and a structure
that the host program uses to list, create, and extract information
about plug-ins.

<div class="in">
<h3><a name="Interface Function">Interface Function</a></h3>
<p>
This function returns a pointer to an
<a href="#Interface Structure">interface structure</a>.
It can be a pointer to a statically defined structure
or a dynamically created one.

<div class="in">
<p><b>Declaration</b><br>
<code>extern "C" Interface *GetInterface( void );</code>
<p><b>Purpose</b><br>
This function is called by the host program to get information about
what plug-ins are available in the plug-in module.  The function
returns a pointer to a initialized
<a href="#Interface Structure">interface structure</a>.
The return value may be NULL if the interface structure could not be
created or some other error occurred.  If the interface structure is
dynamically created by the function, then the structure must exist throughout
the life of the plug-in module, until the module is freed/unloaded by the host
program.  If the function is called more than once, then the same
pointer must be returned each time.

<p>Note that each <a href="#Plug-in Classes">plug-in class</a> has its
own declaration for this function.  The table summarizes these
declarations.  The
declaration ending in "Dll" is what the plug-in developer uses,
while the "App" one is what the host program developer uses.

<p>
<table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Plug-in Class</th><th align=left>Plug-in Module Function</th><th align=left>Host Program Function</th></tr>
<tr><td>File Format</td><td>AudioInterfaceDll</td><td>AudioInterfaceApp</td></tr>
<tr><td>Effect</td><td>EffectInterfaceDll</td><td>EffectInterfaceApp</td></tr>
<tr><td>Visual</td><td>VisualInterfaceDll</td><td>VisualInterfaceApp</td></tr>
</table>

<p><b>Example</b><br>
Defines an Effect interface function that returns a trivial
static <a href="#Interface Structure">interface structure</a>.  Normally
the interface structure would be
initialized with more meaningful information.

<p><pre>
#include "gweffect.h"

Gfx::Interface	ExampleInterface = { EffectVersion, 0, 0, 0, 0 };

EffectInterfaceDll( void )
{
	return &amp;ExampleInterface;
}
</pre>
</div>

<h3><a name="Interface Structure">Interface Structure</a></h3>
<p>
This structure contains version information, the number of
plug-ins contained in the module, plug-in details, a plug-in
creator function, and a pointer to a configuration function.
The host program uses this information to select, manage, and
create plug-ins within the module.

<div class="in">
<p><b>Declaration</b><br>
<pre>
struct Interface
{
	float            version;
	int              count;
	Table            *list;
	CreateFn         create;
	Gbase::ConfigFn  config;
};
</pre>

<p><b>Purpose</b><br>
This structure provide all the information the host program needs
to use the plug-in module.
<p>
<table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>version</code>
</td>
<td>
	Gives the version number of the plug-in interface that the module uses,
	such as 1.0.
	Plug-in developers must use the predefined version defined in the
	header files, such as <code>AudioVersion</code>,
	<code>EffectVersion</code>, or <code>VisualVersion</code>.
	<p>Host programs use the version member to determine if the plug-in module
	uses a compatible interface.
</td>
</tr>

<tr>
<td valign=top>
	<code>count</code>
</td>
<td>
	Gives the number of plug-ins contained in the <code>list</code>
	array member.
	It tells the host program how many plug-ins are contained in
	the module.  A <a href="#Plug-in Table">Table</a> element must exist
	in the <a href="#Interface::list"><code>list</code></a> array for
	each plug-in.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Interface::list"><code>list</code></a>
</td>
<td>
	Contains a pointer to an array of Table objects, which contain
	details about each plug-in, such as the name, abilities, and
	icon.  The number of elements in the list is determined by
	the <code>count</code> member above.  The information stored in
	the list depends on the <a href="#Plug-in Classes">class</a> of plug-in.
	See	<a href="#Plug-in Table">Plug-in Table</a> for more information.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Interface::create"><code>create</code></a>
</td>
<td>
	Contains a pointer to a function that creates a plug-in.
	The host program uses this function pointer to create a plug-in within
	the module.
	See <a href="#Plug-in Creator Function">Plug-in Creator Function</a>
	for more information.
</td>
</tr>

<tr>
<td valign=top>
	<code>config</code>
</td>
<td>
	Contains a pointer to a function that configures the entire module.
	Normally this member will be NULL.
	See <a href="#Module Configuration">Module Configuration</a>
	for more information.
</td>
</tr>

</table>

</div>

<p>

<h3><a name="Plug-in Table">Plug-in Table</a></h3>

The Table structure contains details about a plug-in.  These
include the plug-in's name, abilities, or other information.
The structure varies slightly between the different
<a href="#Plug-in Classes">plug-in classes</a>.  The File
Format class includes a member for listing file types
supported by a plug-in.  The Effect class includes a
member for an icon to use on the host program's tool
bar.  The plug-in name and abilities members are common to all
classes.  The declarations and details for the Effect, File Format,
and Visual tables are given below.

<div class="in">
<h4><a name="Plug-in Table Effect">Effect Table</a></h4>

<p><b>Declaration</b><br>
<pre>
struct Table	// Effect Table
{
	const wchar_t	*name;
	unsigned	abilities;
	int		image;
};
</pre>
<p><b>Purpose</b><br>
Holds information about an Effect plug-in.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<a name="Effect::name"><code>name</code></a>
</td>
<td>
	Gives the name of the effect.
	The host program displays this string in the menu.  Each effect
	in the module must have a unique name.  The name must not contain
	control characters, ampersand, or greater/less than symbols.
	The host program passes this name to the
	<a href="#Plug-in Creator Function">plug-in creator function</a>
	to create a plug-in object for the effect.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Effect::abilities"><code>abilities</code></a>
</td>
<td>
	These are bits that are logically ORed together to define the abilities
	of the effect.  It is critical that the correct bits are
	set for proper handling of an effect by the host program.  The
	plug-in's <a href="#PluginObject::Ability"><code>Ability</code></a>
	member function must return exactly the same abilities.

	<p><table align="center" border="0" width="100%" cellpadding=2>
	<tr><th align=left>Ability</th><th align=left>Purpose</th></tr>
	<tr><td valign=top>aPage</td><td>The effect has a properties page for
	setting and can read and write settings.</td></tr>
	<tr><td valign=top>aScanRequested</td><td>The effect would like to scan
	all the audio, but can still work if scanning is not possible.  The Offset
	effect in GoldWave uses this bit.</td></tr>
	<tr><td valign=top>aScanRequired</td><td>The effect has to scan all
	the audio, otherwise the effect should not be used.  The Maximize/Match
	effects in GoldWave use this bit.  Such effects cannot be chained.</td></tr>
	<tr><td valign=top>aSeekableRequired</td><td>The effect must be able
	to seek to any point in the audio, otherwise the effect should not
	be used.  The Interpolate effect in GoldWave use this bit.  Such
	effects cannot be chained.
	</td></tr>
	<tr><td valign=top>aClipboardRequested</td><td>The effect would like
	to access clipboard audio, but still works if it is not available.</td></tr>
	<tr><td valign=top>aClipboardRequired</td><td>The effect must have
	access to clipboard audio, otherwise the effect should not be used.</td></tr>
	<tr><td valign=top>aFixedLength</td><td>The effect must have a fixed
	length audio source.  It cannot be used on a live recording or in
	conjunction with an effect that alters the length of the audio.  The
	Volume Shape effect in GoldWave uses this bit.  Such effects cannot
	be chained.</td></tr>
	<tr><td valign=top>aChangesLength</td><td>Lets the host program
	know that the effect changes the length of the audio.  The Time
	Warp and Doppler effects in GoldWave use this bit.</td></tr>
	<tr><td valign=top>aStereoRequired</td><td>The effect only works
	on stereo files.  All effects under the Stereo menu in GoldWave
	use this bit.</td></tr>
	<tr><td valign=top>aDiscontinuous</td><td>The effect may delete or
	replace sections of audio.  The Silence Reduction effect in GoldWave
	uses this bit.</td></tr>
	<tr><td valign=top>aModifiesAllChannels</td><td>The effect cannot avoid
	modifying both the left and right channels.  The host program much
	replace any channels that are not supposed to be modified.  The Reverse,
	Doppler, Pitch, and Time Warp effects in Goldwave use this bit.</td></tr>
	</table>
</td>
</tr>

<tr>
<td valign=top>
	<code>image</code>
</td>
<td>
	Gives the integer resource identifier of the plug-in's icon.
	The icon must be 16x16 pixels in size with a transparent background.
</td>
</tr>
</table>

<p><b>Example</b><br>
A sample table for a module with two effects.
<pre>
Gfx::Table EffectTable[] =
{
	{ "Invert", 0, IDI_INVERT },
	{ "Volume", aPage, IDI_VOLUME }
};
</pre>

<h4><a name="Plug-in Table File Format">File Format Table</a></h4>
<p><b>Declaration</b><br>
<pre>
struct Table	// File Format Table
{
	const wchar_t	*name;
	unsigned	abilities;
	const wchar_t	*extensions;
};
</pre>
<p><b>Purpose</b><br>
Holds information about an AudioFile plug-in.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<a name="AudioFile::name"><code>name</code></a>
</td>
<td>
	Gives the name of the plug-in.  This must be a string that describes
	the file type, such as "Wave", "Windows Media Audio", "MPEG Audio", etc.
	Each plug-in in the module must have a unique name/type.
	The host program displays this string when providing a list of
	file types it supports.  The string <b>must not</b> contain path or
	drive separator characters, like slash, back-slash, colon,
	control characters, greater/less than, or ampersand.
	The host program may pass this name to the
	<a href="#Plug-in Creator Function">plug-in creator function</a>
	to create a plug-in object to handle a given file type.  The host program
	may pass the filename itself
	into the <a href="#Plug-in Creator Function">plug-in creator
	function</a>.  Therefore, the creator function must be able to
	determine if any of the
	plug-ins in the module can support the given file.  See the host program
	<a href="#Audio Host Reading">Reading</a> section for details.
</td>
</tr>

<tr>
<td valign=top>
	<a name="AudioFile::abilities"><code>abilities</code></a>
</td>
<td>
	These are bits that are logically ORed together to define the abilities
	of the plug-in. The
	plug-in's <a href="#PluginObject::Ability"><code>Ability</code></a>
	member function must return exactly the same abilities.

	<p><table align="center" border="0" width="100%" cellpadding=1>
	<tr><th align=left>Ability</th><th align=left>Purpose</th></tr>
	<tr><td>aPage</td><td>The plug-in has a properties page where a custom format can be specified manually.</td></tr>
	<tr><td>aRead</td><td>The plug-in can read and decode files.</td></tr>
	<tr><td>aWrite</td><td>The plug-in can write and encode files.</td></tr>
	<tr><td>aRaw</td><td>The plug-in can handle raw audio data.</td></tr>
	<tr><td>aMetaText</td><td>The plug-in supports text information, such as copyright, artist, title.</td></tr>
	<tr><td>aMetaCue</td><td>The plug-in supports cue point information.</td></tr>
	<tr><td>aMetaPicture</td><td>The plug-in supports pictures/artwork/images.</td></tr>
	</table>
</td>
</tr>

<tr>
<td valign=top>
	<code>extensions</code>
</td>
<td>
	Gives a list of extensions that the plug-in handles, such as
	"wav", "wma", "mp3", etc.  If a single plug-in handles more
	than one type, then several extensions can be included in the
	string, separated by a comma and a space, such as "wav, wma, asf".
	This list aids the host program in finding a plug-in that supports
	a file.  The first item in the list must be the
	default extension, usually the same returned by
	<a href="#Format::Extension"><code>Format::Extension</code></a>.
	It is strongly recommend that only one extension per plug-in
	be used.  All letters must be lowercase.
</td>
</tr>
</table>

<p><b>Example</b><br>
A sample table for several popular audio types.
<pre>
Gap::Table FileTable[] =
{
	{ L"Wave", aRead | aWrite | aInfo | aCue, L"wav" },
	{ L"Apple", aRead | aWrite | aInfo | aCue, L"aiff, aifc, aif, afc" },
	{ L"MPEG Audio", aRead | aWrite | aInfo, L"mp3" }
};
</pre>

<h4><a name="Plug-in Table Visual">Visual Table</a></h4>

<p><b>Declaration</b><br>
<pre>
struct Table	// Visual Table
{
	const wchar_t	*name;
	unsigned	abilities;
};
</pre>
<p><b>Purpose</b><br>
Holds information about a Visual plug-in.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<a name="Visual::name"><code>name</code></a>
</td>
<td>
	Gives the name of the visual.
	The host program displays this string in the menu so that a user
	can select it.  Each visual
	in the module must have a unique name.
	The host program passes this name to the
	<a href="#Plug-in Creator Function">plug-in creator function</a>
	to create a plug-in object for the visual.  The name must not
	contain any control characters, greater/less than, or ampersand.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Visual::abilities"><code>abilities</code></a>
</td>
<td>
	These are bits that are logically ORed together to define the abilities
	of the visual. The
	plug-in's <a href="#PluginObject::Ability"><code>Ability</code></a>
	member function must return exactly the same abilities.

	<p><table align="center" border="0" width="100%" cellpadding=2>
	<tr><th align=left>Ability</th><th align=left>Purpose</th></tr>
	<tr><td valign=top>aPage</td><td>The visual has a properties page for setting and can read and write settings.</td></tr>
	<tr><td valign=top>aStatus</td><td>The visual can work in the Status window.</td></tr>
	<tr><td valign=top>aLevel</td><td>The visual can work in the Level window.</td></tr>
	<tr><td valign=top>aLeft</td><td>The visual can work in the Left graph window.</td></tr>
	<tr><td valign=top>aRight</td><td>The visual can work in the Right graph window.</td></tr>
	<tr><td valign=top>aEvent</td><td>The visual accepts events.</td></tr>
	<tr><td valign=top>aOpenGL</td><td>The visual uses OpenGL.</td></tr>
	<tr><td valign=top>aGraph</td><td>The visual works in either of the graph windows.  This is an ORed combination of aLeft and aRight.</td></tr>
	<tr><td valign=top>aAny</td><td>The visual works anywhere.  This is an ORed combination of aStatus, aLevel, aLeft, and aRight.</td></tr>
	</table>
	<p>At least one of aStatus, aLevel, aLeft, and aRight must be set.
</td>
</tr>
</table>

<p><b>Example</b><br>
A sample table for a module with two visuals.
<pre>
Gvp::Table VisualTable[] =
{
	{ L"Time", aStatus },
	{ L"Waveform", aGraph | aPage }
};
</pre>

</div>

<h3><a name="Plug-in Creator Function">Plug-in Creator Function</a></h3>

The host program uses the plug-in creator function pointer in
the <a href="#Interface Structure">interface structure</a>
to create a plug-in
object within the plug-in module.  In most cases, the name of the
plug-in given in the <a href="#Plug-in Table">Plug-in Table</a> is
passed to this function and the plug-in module creates an appropriate
plug-in object.  However, in the case of the File Format Plug-in class,
a filename may be passed to this function.  The creator function
must determine if any plug-ins within its module can support the file
and, if so, create an appropriate plug-in object to handle the file.

<p>A host program may create several copies of a plug-in.  Therefore
a plug-in must never use any global data that may be altered by
multiple copies of the plug-in
at the same time.  Any global data used by a plug-in must be constant.

<div class="in">
<p><b>Declarations</b><br>
<code>typedef Gfx::Effect *(gdecl *CreateFn)( const wchar_t *name );</code><br>
<code>typedef Gap::AudioFile *(gdecl *CreateFn)( const wchar_t *name );</code><br>
<code>typedef Gvp::Visual *(gdecl *CreateFn)( const wchar_t *name );</code><br>

<p><b>Purpose</b><br>
Creates the named plug-in object.

<p><b>Example</b><br>
Illustrates a simple effect creator function.
<pre>
static const wchar_t *EchoName = "Echo";

class EchoEffect : public Effect
{
public:
	const wchar_t * gdecl Name( void ) { return EchoName; }
	// Fill in rest of derived effect code here
};

Gfx::Effect * gdecl Create( const wchar_t *name )
{
	if ( name &amp;&amp; wcscmp( name, EchoName ) == 0 )
		return new EchoEffect;
	return 0;
};
</pre>
</div>

<h3><a name="Module Configuration">Module Configuration</a></h3>

A plug-in developer can use the <code>config</code> member of the
<a href="#Interface Structure">interface structure</a> to
change settings that would alter all plug-ins in the module,
such as displaying a properties window for changing language settings
or processing precision.  The DirectX Wrapper Plug-in included with GoldWave
uses this feature to display a properties window where users select what
DirectX Audio Plug-ins will be available.

Host programs use this function pointer to execute the module's
configuration.  GoldWave, for example, displays configuration
commands under the <b>Options | Plug-in</b> menu.

<div class="in">
<p><b>Declaration</b><br>
<code>typedef bool (gdecl *ConfigFn)( void *ParentWindow );</code>
<p><b>Purpose</b><br>
This function is called by the host program to display a
module configuration window.  The function returns true if
the settings have changed or false if no changes were made.

<p><b>Example</b><br>
Demonstrates a simple language module configuration function.
<pre>
#include "gweffect.h"

enum { English, French };
int language = English;

bool gdecl Configure( void *ParentWindow )
{
	int reply, current = language;

	reply = MessageBox( (HWND)ParentWindow, "Enable French language?",
				"My Module", MB_YESNO | MB_ICONQUESTION );
	if ( reply == IDYES )
		language = French;
	else
		language = English;

	return language != current;
}

Interface ExampleInterface = { EffectVersion, 0, 0, 0, Configure };
</pre>
</div>

</div>

<h2><a name="PluginObject">PluginObject</a></h2>

<p>All plug-ins are C++ classes derived from the PluginObject base
class.  The PluginObject provides functionality common to all plug-ins.
Since multiple instances of a plug-in object may be created, plug-in
objects must never modify any global data in its module.  Plug-in
developers <b>must not</b> derive objects directly from the PluginObject
base class.
Derive from the <a href="#Effect Class">Effect</a>,
<a href="#AudioFile Class">AudioFile</a>, or
<a href="#Visual Class">Visual</a> classes instead.

<p>Plug-in base classes belong to the <code>Gbase</code> namespace.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class PluginObject
{
protected:
	virtual ~PluginObject( void );
public:
	PluginObject( void );

	void 				*programdata;
	virtual void gdecl		Destroy( void );
	virtual const wchar_t * gdecl	Name( void ) = 0;
	virtual unsigned gdecl		Ability( void );
	virtual Page * gdecl		GetPage( void );
	virtual bool gdecl		Get( ConfigWrite &amp;write );
	virtual bool gdecl	 	Set( ConfigRead &amp;read );
};
</pre>

<p><b>Purpose</b><br>
This is the base class for all plug-in objects.  At a minimum, the
<code>Name</code> and <code>Ability</code> member functions must
be overridden.  If the plug-in displays a properties page
for settings, then the <code>GetPage</code>, <code>Get</code>,
and <code>Set</code> functions must be overridden.

<p>Depending on the class of plug-in (Effect, File Format, or Visual),
several other functions must be overridden to provide the new
functionality.  Those are discussed later.

<p>The host program owns any plug-ins it creates and will destroy
them when they are no longer needed.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>~PluginObject</code>
</td>
<td>
	This is the protected virtual destructor.  Since the plug-in object
	is created in the plug-in module's address space, the host program
	must never use <code>delete</code> to destroy a plug-in object.
	The host program must use the <code>Destroy</code> member function
	instead.  Plug-in developers are free to use either the dectructor
	or the <code>Destroy</code> function to clean up an object, but
	they must not delete an object that the host program is still using.
	If overriding the <code>Destroy</code> function, then the base
	class <code>Destroy</code> function must be called to ensure the
	object is deleted, but that could cause <code>delete</code> to be
	called twice.  Therefore it is recommended that the destructor
	be overridden instead of the <code>Destroy</code> function to
	avoid such problems.
</td>
</tr>

<tr>
<td valign=top>
	<code>PluginObject</code>
</td>
<td>
	This is the constructor.  It simply initializes the
	<code>programdata</code> member to 0.  Use the constructor in
	a derived class to initialize the plug-in.
</td>
</tr>

<tr>
<td valign=top>
	<code>programdata</code>
</td>
<td>
	This is a pointer the host program may use to associate additional
	data with the plug-in object.  Plug-in developers <b>must not</b> use
	this member in any way.
</td>
</tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	Since the plug-in object is created in the plug-in module's address
	space, the host program cannot use <code>delete</code>.  Instead,
	the host program uses this function to destroy the object, which
	deletes it within the module's address space.  It is recommended
	that plug-in developers not override this member.  This function
	should contain only a single call to <code>delete</code> and nothing
	more.  The function can be overridden to prevent the host program from
	deleting the object.
</td>
</tr>

<tr>
<td valign=top>
	<a name="PluginObject::Name"><code>Name</code></a>
</td>
<td>
	Returns a pointer to a string containing the name of the plug-in.
	This string must be identical to the name given in the
	<a href="#Plug-in Table">plug-in table</a>.  The host program
	uses this string to identify the plug-in.  In some cases, it
	may be used to create another copy of the plug-in object by
	passing it into the
	<a href="#Plug-in Creator Function">plug-in creator function</a>.
</td>
</tr>

<tr>
<td valign=top>
	<a name="PluginObject::Ability"><code>Ability</code></a>
</td>
<td>
	This returns ability bits the host program uses to determine
	what features are implemented by the plug-in object.  It is
	strongly recommended that this function directly returns the
	abilities for the plug-in in its <a href="#Plug-in Table">Plug-in Table</a>
	entry to avoid any inconsistencies between the table and this member
	function's return value.

	<p><b>Example</b>
	<pre>
unsigned gdecl VolumeEffect::Ability( void )
{
	return EffectTable[VolumeIndex].abilities;
}
	</pre>

	Currently only the <code>baPage</code> (or <code>aPage</code> for
	derived <a href="#Plug-in Classes">plug-in classes</a>) bit is defined for
	the base class.
	It indicates that the plug-in object has a properties page and can get
	and set settings.  Other <a href="#Plug-in Classes">plug-in class</a>
	define more abilities.  See these links for details:
	<ul>
		<li> <a href="#Effect::abilities">Effect Abilities</a>
		<li> <a href="#AudioFile::abilities">AudioFile Abilities</a>
		<li> <a href="#Visual::abilities">Visual Abilities</a>
	</ul>
</td>
</tr>

<tr>
<td valign=top>
	<a name="PluginObject::GetPage"><code>GetPage</code></a>
</td>
<td>
	Returns a pointer to a <a href="#Page">Page</a> object that
	manages a properties page.  The <code>Ability</code> member
	function must return the <code>aPage</code> bit for the
	host program to use this function.  The <code>Get</code>
	and <code>Set</code> members must be overriden as well.
	The properties page must show the current plug-in settings,
	when displayed.  The function must return NULL if it cannot
	create a page.  If the function is called multiple times,
	it must return the same pointer.  If multiple copies of the
	plug-in object are created, then each copy must return its
	own independent page.
</td>
</tr>

<tr>
<td valign=top>
	<a name="PluginObject::Get"><code>Get</code></a>
</td>
<td>
	The host program calls this function passing in a
	<a href="#ConfigRead and ConfigWrite">ConfigWrite</a> object to
	obtain the plug-ins settings.  This function must write all settings
	to the <code>ConfigWrite</code> object.  It is recommended that
	a version number be included first in the written settings
	so that any updates
	to the plug-in will be able to gracefully handle older settings.
	It will also allow an older version of the plug-in to detect
	and reject newer settings a host program may provide.  The
	function must return <code>false</code>
	only if the settings cannot be written.
</td>
</tr>

<tr>
<td valign=top>
	<a name="PluginObject::Set"><code>Set</code></a>
</td>
<td>
	The host program calls this function passing in a
	<a href="#ConfigRead and ConfigWrite">ConfigRead</a> object
	to set the plug-in settings.  The plug-in object reads all the settings
	from the <code>ConfigRead</code> object.  The plug-in must update the
	properties page, if currently displayed, to show the new settings.  The
	function returns <code>true</code> only if the settings are
	compatible and useable.
</td>
</tr>

</table>

</div>

<div class="in">
<h3><a name="Page">Page</a></h3>
This class manages a properties page.  Plug-ins with a properties
page must create a derived class to provide
the required functionality.  Many of the members are pure virtual
functions that must be overridden.  The host program is responsible
for destroying the Page object.  Plug-in developers must add code
to detect when the Page has been destroyed.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class Page
{
protected:
	virtual ~Page( void );

public:
	virtual void gdecl		Destroy( void );

	virtual void * gdecl		Handle( void *ParentWindow ) = 0;
	virtual void gdecl		Show( void ) = 0;
	virtual void gdecl		Hide( void ) = 0;
	virtual const wchar_t * gdecl	Help( void );
	virtual void gdecl		Update( void );
	virtual bool gdecl 		Apply( void );
	virtual void gdecl		Resize( int width, int height );
	virtual int gdecl		Width( void ) = 0;
	virtual int gdecl		Height( void ) = 0;
	virtual unsigned gdecl		Ability( void );
};
</pre>

<p><b>Purpose</b><br>
This class manages a properties page (a graphical user interface for settings).
The page must be a child window or a window that can be contained
within another window created by the host program.  Under Windows,
a dialog window must have <code>DS_CONTROL | WS_CHILD</code>
flags and it must not have a frame, border, or caption.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>~Page</code>
</td>
<td>
	Protected virtual destructor, which prevents host program from
	using <code>delete</code>.  A host program must call the
	<code>Destroy</code> member when it is finished with the properties
	page.  The plug-in itself must never destroy its page.

	<p>Any graphical or windowing objects must be hidden and
	destroyed.  The plug-in object must be aware that the page
	was destroyed so that a new one can be created if the
	host program calls the <code>PluginObject::GetPage</code>
	function again.
</td>
</tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	This function is called by the host program to destroy the
	page.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Page::Handle"><code>Handle</code></a>
</td>
<td>
	The host program calls this function to provide the host parent window
	and to get a handle of the page window.  Under Windows, these are
	HWND objects.  This function must create a modeless window with
	the parent set appropriately and return a handle to the new window.
	This window must not be shown initially and must be a child window.
	If this function is called more than once, then the same handle
	must be returned.
</td>
</tr>

<tr>
<td valign=top>
	<code>Show</code>
</td>
<td>
	Shows the page.  If any plug-in settings have changed, those
	settings must be shown.  If any changes are made to the setting
	programatically through the
	<a href="#PluginObject::Set"><code>Set</code></a>
	function, those changes must be made in the page while it
	is shown.
</td>
</tr>

<tr>
<td valign=top>
	<code>Hide</code>
</td>
<td>
	Hides the page.  It must not destroy the page nor free the
	window handle.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Page::Help"><code>Help</code></a>
</td>
<td>
	Returns a string containing information about where the help
	is located.  This can be a URL beginning with "http://"
	or a filename and a help topic separated by quotes.  If it is
	a filename and topic, the
	first character in the string must be a quote and
	the filename and help topic must be enclosed in separate quotes
	so that there are at least four quotes in the string.
	The function may display its own help window and return NULL.

	<p>The <code>paHelp</code> ability must
	be returned by the page's
	<a href="#Page::abilities"><code>Ability</code></a> function for the
	host program to know it must provide/enable a Help button.

	<p><b>Examples:</b><br>
<pre>
// Return a URL
return L"http://www.somewhere.com/pluginhelp.html";

// Return a local HTML file in the plug-in folder
return L"http:///pluginhelp.html";

// Return a section in a local HTML file in the plug-in folder
// Unfortunately multiple browser windows may be opened when using
// anchors because Windows does a poor job of handing such URLs and
// hacks are required to get them working at all.
return L"http:///pluginhelp.html#anchor";

// Return a WinHelp file and topic/key in the plug-in folder
return L"\"pluginhelp.hlp\" \"topic\"";

// Do it directly
WinHelp( hwnd, L"pluginhelp.hlp", HELP_CONTENTS, 0 );
return 0;
</pre>
</td>
</tr>

<tr>
<td valign=top>
	<a name="Page::Update"><code>Update</code></a>
</td>
<td>
	Advises the page to perform any command enabling or idle processing.
	This function can be overridden to disable buttons/features when
	previewing an Effect plug-in.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Page::Apply"><code>Apply</code></a>
</td>
<td>
	The host program calls this function to apply settings
	to the plug-in.  The <code>paApply</code> ability must
	be returned by the page's
	<a href="#Page::abilities"><code>Ability</code></a>
	function for the
	host program to know it must provide/enable an Apply button.
	Override this function when implementing an Effect plug-in that does
	not support real-time changes of settings during previewing.  This
	should be avoided when possible.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Page::Resize"><code>Resize</code></a>
</td>
<td>
	The host program calls this function to resize the page.
	The <code>paResize</code> ability must
	be returned by the page's
	<a href="#Page::abilities"><code>Ability</code></a> function to
	tell the host program that the parent window should be resizable.
	This function must resize the page to the given
	<code>width</code> and <code>height</code>.  Note
	that this function is called by the
	host program after the page is created
	even when the <code>paResize</code> ability is
	not given.  The page can take advantage of this call to
	center itself within the parent window.
</td>
</tr>

<tr>
<td valign=top>
	<code>Width</code>
</td>
<td>
	Returns the initial or current width of the page to the
	host program.  The host program uses this to determine the width
	of the parent window so that the page can be contained
	within it.
</td>
</tr>

<tr>
<td valign=top>
	<code>Height</code>
</td>
<td>
	Returns the initial or current height of the page to the
	host program.  The host program uses this to determine the height
	of the parent window so that the page can be contained
	within it.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Page::abilities"><code>Ability</code></a>
</td>
<td>
	This function returns ability bits the host program uses to determine
	what features are implemented by the page.

	<p><table align="center" border="0" width="100%" cellpadding=2>
	<tr><th align=left>Ability</th><th align=left>Purpose</th></tr>
	<tr><td valign=top>paApply</td><td>An Apply button is required.</td></tr>
	<tr><td valign=top>paResize</td><td>The page is resizable.</td></tr>
	<tr><td valign=top>paHelp</td><td>The page has help.</td></tr>
	</table>

</td>
</tr>
</table>

</div>

<h3><a name="ConfigRead and ConfigWrite">ConfigRead and ConfigWrite</a></h3>
These classes provide a mechanism for reading and writing plug-in
settings, such as effect parameters, custom file format settings,
and visual properties.

<div class="in">
<p><b>Declarations</b><br>
<pre>
class ConfigRead
{
public:
	virtual bool gdecl ReadString( wchar_t *string, int len ) = 0;
	virtual bool gdecl Read( void *data, int len ) = 0;
	template &lt;class T&gt; bool Read( T &amp;value );
	template &lt;class T&gt; ConfigRead &amp;operator&gt;&gt;( T &amp;value );
};

class ConfigWrite
{
public:
	virtual bool gdecl WriteString( const wchar_t *string ) = 0;
	virtual bool gdecl Write( const void *data, int len ) = 0;
	template &lt;class T&gt; bool Write( const T &amp;value );
	template &lt;class T&gt; ConfigWrite &amp;operator&lt;&lt;( const T &amp;value );
};
</pre>

<p><b>Purpose</b><br>
These classes are derived by the host program and the objects
are passed to a plug-in's <a href="#PluginObject::Get"><code>Get</code></a>
and <a href="#PluginObject::Set"><code>Set</code></a>
member functions to read and write settings.  A host
program typically uses these objects to save settings for use
at a later time, such as Effect presets in GoldWave or to store/load
properties for visuals the next time the program is started.

<p>Plug-in developers never need to derive from these classes.
Plug-ins must use the objects passed to them in their
<a href="#PluginObject::Get"><code>Get</code></a>
and <a href="#PluginObject::Set"><code>Set</code></a> member functions.

<p>These functions should catch <code>ConfigException</code>
exceptions if using the streaming operators.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th colspan="2">ConfigRead</th></tr>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top width="40%">
	<code>ReadString( wchar_t *string, int len )</code>
</td>
<td>
Read a null terminated string from the configuration data.
The maximum length of the string is given in <code>len</code>.
Returns true if successful, or false if no string data is available.
</td>
</tr>

<tr>
<td valign=top>
	<code>Read( void *data, int len )</code>
</td>
<td>
Reads <code>len</code> bytes of data from the configuration.
Returns true if all data can be read or false otherwise.  If all data
cannot be read, then the function fails and does not alter
the current position within the configuration data.
</td>
</tr>

<tr>
<td valign=top>
	<code>Read( T &amp;value )</code>
</td>
<td>
Reads any kind of value.  Throws <code>ConfigException</code> if
the value cannot be read.
</td>
</tr>

<tr>
<td valign=top>
	<code>operator&gt;&gt;( T &amp;value )</code>
</td>
<td>
Reads any kind of value through streaming.
Throws <code>ConfigException</code> if the value cannot be read.
</td>
</tr>

<tr><th colspan="2">ConfigWrite</th></tr>

<tr>
<td valign=top>
	<code>WriteString( wchar_t *string )</code>
</td>
<td>
Writes a null terminated string to the configuration data.
Returns true if successful, or false if no storage is available.
</td>
</tr>

<tr>
<td valign=top>
	<code>Write( void *data, int len )</code>
</td>
<td>
Writes <code>len</code> bytes of data to the configuration.
Returns true if all data can be written or false otherwise.  If all data
cannot be written, then the function fails and does not alter
the current position within the configuration data.
</td>
</tr>

<tr>
<td valign=top>
	<code>Write( T &amp;value )</code>
</td>
<td>
Writes any kind of value.  Throws <code>ConfigException</code> if
the value cannot be written.
</td>
</tr>

<tr>
<td valign=top>
	<code>operator&lt;&lt;( const T &amp;value )</code>
</td>
<td>
Writes any kind of value through streaming.
Throws <code>ConfigException</code> if the value cannot be written.
</td>
</tr>

</table>


<p><b>Example</b><br>
Basic <code>Get</code> and <code>Set</code> functions
for an effect plug-in that has volume and balance settings.
<pre>
const float SettingsVersion = 1.0;

bool gdecl MyPlugin::Get( ConfigWrite &amp;write )
{
	try
	{
		// Write version and settings
		write &lt;&lt SettingsVersion &lt;&lt volume &lt;&lt balance;
	}
	catch( ConfigException &amp; )
	{
		return false;
	}
	return true;
}

bool gdecl MyPlugin::Set( ConfigWrite &amp;write )
{
	float version;

	try
	{
		// Read version
		read &gt;&gt; version;
		if ( version &gt; SettingsVersion )
			return false;

		// Read settings.  May need a critical section for more complex cases
		read &gt;&gt; volume &gt;&gt; balance;

		// If a page was created and is shown, update it here
	}
	catch( ConfigException &amp; )
	{
		return false;
	}
	return true;
}
</pre>
</div>
</div>

<h2><a name="audio Type">audio Type</a></h2>

<p>The <code>audio</code> type is used in File Format and Effect plug-ins.

<div class="in">
<p><b>Declaration</b><br>
<pre>typedef float   audio;</pre>
<p><b>Purpose</b><br>
This is the type for a single sample of one audio channel.  It
is a 32 bit, IEEE floating point value in the range of -1.0 to
1.0.  Effects may generate values that exceed this range, but
it is recommended to limit values when necessary.

<p>Stereo audio is stored interleaved with the left
channel value
first, followed by the right channel value like this: L R L R L R....
Even elements (<code>y[0], y[2],</code> etc.) refer to
the left channel values and odd elements (<code>y[1],
y[3],</code> etc.) refer to the right channel values.  Note
that a pair of left and right values is considered a single sample
for stereo audio.

<p><b>Example</b><br>
<pre>
#include "gwaudiotype.h"

audio AverageChannels( audio *y )
{
	return (audio)((y[0] + y[1]) / 2);
}
</pre>
</div>

<h2><a name="Error Codes">Error Codes</a></h2>

<p>Error codes are given in the gwerror.h file under the
<code>Gerr</code> namespace.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Code</th><th align=left>Meaning</th></tr>

<tr>
<td valign=top>
	<code>eNone</code>
</td>
<td>
No error occurred.  Function completed successfully.
</td>
</tr>

<tr>
<td valign=top>
	<code>eCreate</code>
</td>
<td>
The file could not be created.  The file may already exist, or
the filename is invalid, or there is not enough storage, or the
storage device is not ready, or the file is in use by another
program.  Returned from the
<a href="#AudioFile::Begin"><code>AudioFile::Begin</code></a> function.
</td>
</tr>

<tr>
<td valign=top>
	<code>eOpen</code>
</td>
<td>
The file could not be opened.  The file does not exist.
Returned from the
<a href="#AudioFile::Open"><code>AudioFile::Open</code></a> function.
</td>
</tr>

<tr>
<td valign=top>
	<code>eRead</code>
</td>
<td>
Audio data could not be read.  The device/drive may not be ready
(CD was ejected) or some kind of read error occurred.
</td>
</tr>

<tr>
<td valign=top>
	<code>eWrite</code>
</td>
<td>
Audio data could not be written.  The device/drive may be full
or some kind of write error occurred.
</td>
</tr>

<tr>
<td valign=top>
	<code>eSeek</code>
</td>
<td>
Seeking to a certain position within the audio file failed.
The file may not be seekable or the file is truncated or a device/drive
error occurred.
Returned from
<a href="#AudioFile::Seek"><code>AudioFile::Seek</code></a>.
</td>
</tr>

<tr>
<td valign=top>
	<code>eClose</code>
</td>
<td>
The file could not be closed.
Returned from
<a href="#AudioFile::Close"><code>AudioFile::Close</code></a> or
<a href="#AudioFile::End"><code>AudioFile::End</code></a>.</td>
</tr>

<tr>
<td valign=top>
	<code>eMemory</code>
</td>
<td>
There is not enough memory.  Memory allocation failed.
</td>
</tr>

<tr>
<td valign=top>
	<code>eCorrupt</code>
</td>
<td>
The file is corrupt or contains inconsistent or invalid information,
such as a negative sampling rate or negative channels.
Returned from
<a href="#AudioFile::Open"><code>AudioFile::Open</code></a>.
</td>
</tr>

<tr>
<td valign=top>
	<code>eReadOnly</code>
</td>
<td>
The file is marked as "read only" and cannot be replaced or
overwritten.  Returned from
<a href="#AudioFile::Begin"><code>AudioFile::Begin</code></a>.
</td>
</tr>

<tr>
<td valign=top>
	<code>eClash</code>
</td>
<td>
The file contains multiple streams with different sampling rates
or different number of channels.
Returned from
<a href="#AudioFile::Open"><code>AudioFile::Open</code></a>.
</td>
</tr>

<tr>
<td valign=top>
	<code>eEmpty</code>
</td>
<td>
The file does not contain any audio data.
Returned from
<a href="#AudioFile::Open"><code>AudioFile::Open</code></a>.
</td>
</tr>

<tr>
<td valign=top>
	<code>eCodec</code>
</td>
<td>
There is no appropriate decoder or encoder installed to process the audio data.
Returned from
<a href="#AudioFile::Open"><code>AudioFile::Open</code></a> or
<a href="#AudioFile::Begin"><code>AudioFile::Begin</code></a>.
</td>
</tr>

<tr>
<td valign=top>
	<code>eMath</code>
</td>
<td>
A math exception occurred (division-by-zero, overflow, etc.).
</td>
</tr>

<tr>
<td valign=top>
	<code>eBounds</code>
</td>
<td>
An array index is outside the valid range.
</td>
</tr>

<tr>
<td valign=top>
	<code>eType</code>
</td>
<td>
The file type is not supported by the File Format plug-in.  A File Format
plug-in may return this error if it does not handle the type at all.
</td>
</tr>

<tr>
<td valign=top>
	<code>eFormat</code>
</td>
<td>
The format or encoding is not supported by the File Format plug-in.
A File Format plug-in may return this if it recognizes the file type,
but cannot handle the audio sub-format.
</td>
</tr>

<tr>
<td valign=top>
	<code>eAbort</code>
</td>
<td>
The user aborted processing or processing was cancelled.
</td>
</tr>

<tr>
<td valign=top>
	<code>eUnsupported</code>
</td>
<td>
The function is not supported or implemented.
</td>
</tr>

<tr>
<td valign=top>
	<code>eForbidden</code>
</td>
<td>
The funtion must not be called at this time.  For example, a File Format plug-in
may return this error if more than one AudioFile::Begin call is made
without a matching AudioFile::End call.
</td>
</tr>

<tr>
<td valign=top>
	<code>eParameter</code>
</td>
<td>
A parameter passed to the function is invalid.
</td>
</tr>

<tr>
<td valign=top>
	<code>ePermission</code>
</td>
<td>
The user does not have permission to access the file or resource, such
as a copy-protected or encrypted audio file.
</td>
</tr>

<tr>
<td valign=top>
	<code>eRange</code>
</td>
<td>
A value is out of range, such as when a sample exceeds the maximum
and requires clipping.
</td>
</tr>

<tr>
<td valign=top>
	<code>eException</code>
</td>
<td>
An unrecoverable exception occurred or error occurred.
</td>
</tr>

</table>


<h1><a name="Effect Plug-ins">Effect Plug-ins</a></h1>

<p>Effect plug-ins process and modify audio.  They can filter
frequencies, mix channels, add an echo, delete silences, and
so on.  With the exception of changing the sampling rate or
the number of channels, they can do everything that the effects
in GoldWave do, and even some clipboard mixing and pasting.

<p>The two most important members of an effect plug-in are the
<a href="#Source"><code>source</code></a> pointer and the
<a href="#Read"><code>Read</code></a> function.
Each effect must have an
overridden <code>Read</code> function.  Shortly after
an effect is created by the host program, it is assigned a
<code>source</code>.
The effects are connected together in a chain linked by the sources
and audio is propagated from one link to the next by calling the
<code>Read</code> function.

<p>
<center>
<img src="chain.png" alt="Effect Plug-in Chain"><br>
Figure: Effect Plug-in Chain
</center>

<p>The first link in the chain is usually an effect or transform object
derived and created by the host program to provide the original
source audio.  This audio
may be read from a file, recorded from an audio device, or generated
mathematically.  It does not matter where the audio originates;
a plug-in developer simply needs to call the
<code>Read</code> function of its <code>source</code> to
obtain it.  In order to retrieve the final processed audio, the
host program simply calls the <code>Read</code>
function of the last effect in the chain.  Audio is automatically
processed and passed up the chain to the host program.

<p>For simple effects, a plug-in developer does not need to
handle any buffer allocation.  The buffer is provided by the host
program with its <code>Read</code> call on the
last effect.  However, neither the host program nor a plug-in can
ever request more than <code>MaxSamples</code> in any <code>Read</code> call.
This simplifies memory allocation.  It also eliminates the need to
implement separate functions for more efficient in-place processing since
the processed audio is read in-place automatically.  Note that more complex
processing may require additional buffers.

<p style="color:#C00000;font-weight:bold">Important: Never make a <code>Read</code> call
with a number
larger than <code>MaxSamples</code>.  Do not make any
assumptions about the size of
<code>MaxSamples</code>.  This value may change in future versions of the
SDK.

<p>The host program may use a multithreaded design (GoldWave does).  This means
that the <code>Read</code> call may occur on a different thread than
calls to other member functions (such as
<a href="#PluginObject::Get"><code>Get</code></a> and
<a href="#PluginObject::Set"><code>Set</code></a>).
Mutual exclusions or critical sections may be required depending on
the complexity of the effect to protect member data from multithread
access and modification.  For example, a <code>Set</code> call may
occur right in the middle of a <code>Read</code> call, changing
effect settings.  This <b>will</b> cause errors or faults if the code
is not designed correctly.  For simple effects with no user settings,
this will not be a problem since a <code>Set</code> call won't
occur.  Note that a host must not use more than 2 threads.
The <code>Read</code> call may occur on one thread (and only when
the effect is in the reset or read state, see below).
All other calls must occur on the other thread.  It must never
re-enter the <code>Read</code> function.

<p>An effect typically has three states: the uninitialized state,
the reset state, and the read state.  When the effect
is created and before its source is set, it is in the uninitialized state.
As soon as the source is assigned by the host program, it is in
the reset state, meaning that it is ready to start reading or
scanning audio.
The first time the host program calls the <code>Read</code> function,
the effect is in the read state.  It stays in that
state until the <code>Reset</code> function is called.

<p>The source can be changed only when the effect is in the reset
or uninitialized state.  An effect's settings can be changed at
any time.

<p>Effect related classes belong to the <code>Gfx</code> namespace.

<h2><a name="Transform Class">Transform Class</a></h2>

<p>This class provides a most of the functionality of an effect, but
without the user and host program interface overhead.  Several
derived Transform classes can be combined to create a single effect.
A useful Transform can be reused in several different
effects.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class Transform
{
protected:
	Transform	*source;
	unsigned	channel;
	int		channels,
			rate;

	virtual		~Transform( void ) {}

public:
	Transform( void );
	virtual void gdecl	Destroy( void );
	virtual bool gdecl	Source( Transform *Source );
	virtual int gdecl	Channels( void );
	virtual unsigned gdecl 	Channel( void );
	virtual int gdecl 	Rate( void );

	virtual void gdecl	Reset( void );
	virtual double gdecl	Time( void );
	virtual double gdecl	Start( void );
	virtual double gdecl	Finish( void );
	virtual int gdecl	Update( void );
	virtual int gdecl	Read( audio *buffer, int samples ) = 0;
	virtual bool gdecl	Seek( double time );
};
</pre>
<p><b>Purpose</b><br>
This class provides the basic functionality for an effect.  It
does not carry the overhead of a <a href="#PluginObject">PluginObject</a>.
It is not necessary to override all function.  Only the pure
virtual
<a href="#Read"><code>Read</code></a> function needs to be implemented.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>source</code>
</td>
<td>
	This is a pointer to a <code>Transform</code> object containing
	a source of audio.  It is
	assigned by the host program with a call to the
	<a href="#Transform::Source"><code>Source</code></a> member function.
	The transform reads audio by calling the source object's
	<code>Read</code> member function.  The source may be set to
	NULL later to disconnect it from the chain.

	<p><b>Example</b><br>
	<code>samples = source-&gt;Read( buffer, MaxSamples );</code>

</td>
</tr>

<tr>
<td valign=top>
	<a name="Transform::channel"><code>channel</code></a>
</td>
<td>
	The bits in this variable determine what channels may be modified
	by the transform, as defined by the AudioChannelFlags
	enumeration (in <code>gwaudiotype.h</code>).  Bit values include:
	<p><table align="center" border="0" width="100%" cellpadding=2>
	<tr><th align=left>Value</th><th align=left>Purpose</th></tr>
	<tr><td valign=top>acfLeft</td><td>The left channel may be modified.</td></tr>
	<tr><td valign=top>acfRight</td><td>The right channel may be modified.</td></tr>
	<tr><td valign=top>acfAll</td><td>All channels may be modified.</td></tr>
	</table>
	<p>Note that a transform <b>must not</b> modify a channel if its bit is
	not set.  If an effect uses a transform that cannot
	prevent modifying a channel, then the effect's <code>Ability</code>
	member function and Table
	<a href="#Effect::abilities"><code>abilities</code></a> member
	must include the <code>aModifiesAllChannels</code> bit to tell the
	host program to repair the modified channel.
</td>
</tr>

<tr>
<td valign=top>
	<code>channels</code>
</td>
<td>
	This value holds the number of channels in the audio data.
	Currently only values of 1 (mono) and 2 (stereo) are valid.
</td>
</tr>

<tr>
<td valign=top>
	<code>rate</code>
</td>
<td>
	This value holds the sampling rate of the source audio.  Values
	may range from 100Hz to 192000Hz.
</td>
</tr>

<tr>
<td valign=top>
	<code>~Transform</code>
</td>
<td>
	The protected destructor eliminates any possibility of the host
	program deleting the transform off of its own memory address space.
	Override the destructor to clean up any memory allocation required
	by the transform.
</td>
</tr>

<tr>
<td valign=top>
	<code>Transform</code>
</td>
<td>
	The constructor simply initializes the data members to reasonable
	values.
</td>
</tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	This function is used by the host program to destroy the effect
	and delete it from the plug-in module's address space.  This
	function should not be overridden.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Transform::Source"><code>Source</code></a>
</td>
<td>
	Provides a source for the transform.  See the
	<a href="#Source">Source</a> section below for more information.
</td>
</tr>

<tr>
<td valign=top>
	<code>Channels</code>
</td>
<td>
	Returns the number of channels.  It is rarely
	necessary to override this function.
</td>
</tr>

<tr>
<td valign=top>
	<code>Channel</code>
</td>
<td>
	Returns the
	<a href="#Transform::channel"><code>channel</code></a> flags.  It
	is rarely necessary to override this function.
</td>
</tr>

<tr>
<td valign=top>
	<code>Rate</code>
</td>
<td>
	Returns the sample rate.  It
	is rarely necessary to override this function.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Transform::Reset"><code>Reset</code></a>
</td>
<td>
	Resets the internal state of the transform.
	The transform should reset all variables and clear all buffers
	so that it is in the same state as it was when its source
	was first assigned.  When this function is called by the host program,
	it tells the transform that processing must start from the
	beginning again.  This function <b>must be</b> overridden if the
	transform holds any state information or delay buffers.
	Typically a host program calls <code>Reset</code> after
	previewing so that it can start previewing again from the
	beginning or to begin processing.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Transform::Time"><code>Time</code></a>
</td>
<td>
	Returns the current time with respect to the
	original source file.  It is usually the number of samples processed
	divided by the sampling rate plus the initial start time.  For
	example:<br>
	<pre>
	return Start() + processed_samples / (double)rate;</pre>

	<p>If the transform alters the tempo, buffers any
	audio, or has a delay, it <b>must</b> override
	this function to recalculate the source based time.

	<p>The time returned must be the exact time associated with the last
	sample returned by the most recent <code>Read</code> call.

	<p>This function must be thread safe.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Transform::Start"><code>Start</code></a>
</td>
<td>
	Returns the absolute starting time of the audio.
	In GoldWave, it is the starting time of the selection.  The
	Doppler and Volume Shape effects use this function to obtain
	the starting time for the shape graphs.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Transform::Finish"><code>Finish</code></a>
</td>
<td>
	This function returns the time of the last sample to be processed in
	the source audio, if known.  In GoldWave, this would be the ending time of
	the selection.  Note that this function may return 0 if
	the finish time is not known or cannot be determined, such
	as when processing an unbounded live recording rather than a
	fixed length file.  Transforms must ensure the value is
	not 0 before processing any time dependent (dynamic) effects,
	such as fades, shapes, etc.  If an effect uses a transform
	that requires fixed length audio, it must use the
	<code>aFixedLength</code> bit in its <code>Ability</code>
	member function and Table
	<a href="#Effect::abilities"><code>abilities</code></a>.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Transform::Update"><code>Update</code></a>
</td>
<td>
	Tells the transform that something has changed in the source
	and to check the Start and Finish times	again.  If the
	<code>initiator</code> parameter is a pointer to this transform, then
	the <code>Update</code>	call must not be forwarded (otherwise
	an endless loop will result).  This happens only if this transform
	initiated the <code>Update</code> call in the first place.

	<p>If the <code>update</code> parameter
	is true (and this transform did not initiate the update),
	then this transform should check the Start, Finish, Rate,
	Channels, Channel of its source to see if anything has changed.
	If the <code>update</code> parameter is false, it must forward
	the <code>Update</code> call to its source and do nothing else.

	<p>Note: Not currently implemented in GoldWave.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Transform::Read"><code>Read</code></a>
</td>
<td>
	Processes audio and fills the provided buffer with the requested number
	of samples.  See the
	<a href="#Read">Read</a> section below for more information.
</td>
</tr>

<tr>
<td valign=top>
	<code>Seek</code>
</td>
<td>
	Seeks to a new time within the source.  The <code>time</code>
	parameter is the absolute seek time in seconds.  The function returns
	true if seeking is successful or false if seeking is not supported,
	failed, or is out of range.  For basic effects, this function
	would simply call the source <code>Seek</code> function:
	<pre>
	return source-&gt;Seek( time );</pre>

	<p>Only transforms that
	do not maintain state information may override this function to
	enable seeking.  Seeking is allowed only when the exact same output
	can be calculated at a given time, regardless if a seek occurred
	or not.  Any filters, echoes, flangers that include delay buffers
	must not allow
	seeking because the processed output would vary depending on the
	delayed audio stored in the buffers.

	<p>Seeking
	is prohibited when the output generated for one sample depends on
	other surrounding samples.

	<p>Seeking is used by GoldWave in the Noise Reduction filter to
	draw the frequency graphs, in the Reverse effect to seek to
	the end of the audio and read the audio backwards, and in the
	Interpolate effect to determine the last amplitude.
</td>
</tr>

</table>
</div>


<h2><a name="Effect Class">Effect Class</a></h2>

<p>This is the main plug-in class for effects.  It adds user and
host program (<a href="#PluginObject">PluginObject</a>) interfaces
to the Transform class.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class Effect : public Gbase::PluginObject, public Transform
{
protected:
	virtual ~Effect( void ) {}

public:
	virtual void gdecl	Destroy( void );
	virtual bool gdecl	Scan( Progress &amp;progress );
	virtual bool gdecl	Input( Transform *transform, int input );
};
</pre>
<p><b>Purpose</b><br>
This is the base class for all Effect plug-ins.  To create an effect,
derive a class from this one.  Refer to the
<a href="#PluginObject">PluginObject</a> and
<a href="#Transform Class">Transform Class</a>
sections for more information.  Every derived effect must override the
following functions:
<ul>
<li> <a href="#Transform::Read"><code>Transform::Read</code></a>
<li> <a href="#PluginObject::Ability"><code>PluginObject::Ability</code></a>
<li> <a href="#PluginObject::Name"><code>PluginObject::Name</code></a>
</ul>

<p>If an effect provides a user interface or has settings, it must override the
following functions:
<ul>
<li> <a href="#PluginObject::GetPage"><code>PluginObject::GetPage</code></a>
<li> <a href="#PluginObject::Get"><code>PluginObject::Get</code></a>
<li> <a href="#PluginObject::Set"><code>PluginObject::Set</code></a>
</ul>

Complex effect (such as ones that alter the tempo or have internal buffers)
may have to override these functions:
<ul>
<li> <a href="#Transform::Reset"><code>Transform::Reset</code></a>
<li> <a href="#Transform::Time"><code>Transform::Time</code></a>
<li> <a href="#Transform::Update"><code>Transform::Update</code></a>
</ul>

<p>Effects have <code>Scan</code> and <code>Input</code> member functions
for additional functionality explained in later sections.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>~Effect</code>
</td>
<td>
	Protected destructor prevents host program from accidentally deleting
	object from its own address space.
</td>
</tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	Called by host program to delete object from plug-in module's address
	space.
</td>
</tr>

<tr>
<td valign=top>
	<code>Scan</code>
</td>
<td>
	Tells the effect to begin scanning its source or provides
	a <a href="#Progress Class">Progress</a> object for
	scanning later.  See the
	<a href="#Effect::Scan">Scan</a> section for more information.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Effect::Input"><code>Input</code></a>
</td>
<td>
	The host program calls this member function to provide additional
	audio input sources to the effect, such as a clipboard source.
	For an effect to receive a clipboard input, it must include the
	<code>aClipboardRequested</code> or <code>aClipboardRequired</code>
	bit in its <code>Ability</code>	member function and Table
	<a href="#Effect::abilities"><code>abilities</code></a>.  The effect
	must override this function to store the given transform object.
	If a <a href="#Transform::Reset"><code>Reset</code></a> call occurs,
	the effect must call the <code>Reset</code> member of that
	transform object as well.  See the <a href="#Clipboard">Clipboard</a>
	section for more information.
</td>
</tr>

</table>
</div>

<h2><a name="Source">Source</a></h2>

<div class="in">
<p><b>Declaration</b><br>
<code>virtual bool gdecl Transform::Source( Transform *Source );</code>
<p><b>Purpose</b><br>
The <code>Source</code> member function receives a pointer to a Transform
object it uses to read audio data.  When an effect is
constructed, the <code>source</code> pointer is NULL and no information
about the source audio is known.
An effect may override the <code>Source</code> function to initialize
internal values or allocate buffers based on the sampling rate and
channel information it gathers from the source object.

<p>The overridden <code>Source</code> function <b>must</b> call its
base class <code>Source</code> function to ensure that the base class
has correctly initialized its internal values and buffers.

<p>The source may be changed by the host program when the effect
is in its reset state.  It cannot change the source after making
a <a href="#Effect::Read"><code>Read</code></a> call unless
it calls <a href="#Transform::Reset"><code>Reset</code></a> first.

<p>The host program may pass in NULL as the source when
the effect is being removed from the chain.
</div>

<h2><a name="Effect::Read">Read</a></h2>

<div class="in">
<p><b>Declaration</b><br>
<code>virtual int gdecl Transform::Read( audio *buffer, int samples );</code>
<p><b>Purpose</b><br>
This is the heart of the transform or effect and is where all the
processing occurs.

One of the first things a <code>Read</code>
function must do is to read audio data from the <a href="#Source">source</a>
transform.  For simple effects, the audio can be read directly
into the given <code>buffer</code> pointer, then processed:
<pre>
int gdecl SampleEffect::Read( audio *buffer, int samples )
{
	int read = source-&gt;Read( buffer, samples );

	// Process the number of audio samples read

	return read;
}
</pre>

For more complex effects that consume more samples than are generated, multiple
reads to an internal buffer may be required:
<pre>
int gdecl SampleEffect::Read( audio *buffer, int samples )
{
	int requested = samples;

	while ( requested &lt; 0 )
	{
		int	needed = internal_samples;
		audio	*dest = internal_buffer;

		while ( needed )
		{
			// Read needed audio into internal buffer
			int	count = needed &lt; MaxSamples ? needed : MaxSamples,
				read = source-&gt;Read( dest, count );

			if ( read &lt;= 0 )
				break;
			needed -= read;
			dest += read * channels;
		}

		// ... Process audio and store generated samples in 'buffer'

		requested -= generated;
	}

	return samples - requested;
}
</pre>

<h3><a name="Read Buffer">Read Buffer</a></h3>

<p>The buffer is an array of <code>audio</code> values.  These values
are in the range of -1.0 to 1.0, representing the amplitudes of the
waveform over time.

<p>A <i>sample</i> refers to one or more
<a href="#audio Type"><code>audio</code></a>
values for each channel of audio.
For a mono file, it is a linear array
of single <code>audio</code> values.  For a stereo
file, it is an array of a pair of <code>audio</code> values.
In other words, each stereo sample has two <code>audio</code>
values.  If reading one stereo sample, then the buffer will contain
two <code>audio</code> values.  Stereo values are stored in the buffer
in an interlaced pattern, L R L R ..., such
that even elements in the <code>buffer</code> pointer
(<code>buffer[0], buffer[2],</code> etc.) refer to
the left channel values and odd elements (<code>buffer[1],
buffer[3],</code> etc.) refer
to the right channel values.

<p>When reading from a stereo source, it is important to ensure
that internal buffers are large enough to hold the stereo data.  When
allocating buffers, the byte size must be at least
<code>channels * samples * sizeof(audio)</code>.

<h3><a name="Requested Samples">Requested Samples</a></h3>

<p>The <code>Read</code> function <b>must</b> return the number of requested
<code>samples</code> in the buffer.  The only case where it can return less is when
the source transform does not return the number of requested samples at the
end of processing (or it returns 0 or an error).

<p style="color:#C00000;font-weight:bold">Important:  The <code>Read</code>
function <b>must never</b> return
less than the requested number of samples just because it is convenient
to do so.  It always must return the requested number of samples until the
source does not provide enough samples at the very end.  If the effect
provides less than the requested amount, the host program may conclude it
has reached the end of processing.

<p>The effect does not have to read the required number of samples from
its source at once.  It is free to read as many samples as it requires
(more or less),
provided the amount does not exceed the <code>MaxSamples</code> limit
and it generates the required number of samples before returning.

<p style="color:#C00000;font-weight:bold">Important:  The <code>Read</code>
function must never request more than <code>MaxSamples</code> samples
from its source at one time.  Use multiple source <code>Read</code>
calls if more samples are required.

<h3><a name="Modifying Channels">Modifying Channels</a></h3>

<p>The <code>Read</code> function must modify a channel only if its
corresponding <a href="#Transform::channel"><code>channel</code></a>
bit is set:
<pre>
// Doubles amplitude of all samples
int gdecl DoubleEffect::Read( audio *buffer, int samples )
{
	int read = source-&gt;Read( buffer, samples );

	for ( samples = 0; samples &lt; read; samples++ )
	{
		// Double left amplitude
		if ( channel &amp; acfLeft )
			buffer[0] *= 2;
		// Double right amplitude
		if ( (channel &amp; acfRight) &amp;&amp; channels == 2 )
			buffer[1] *= 2;

		buffer += channels;
	}
	return read;
}
</pre>
<p>If it is impossible for an effect to prevent modification of all channels
(such as a rewind effect or temporal effect),
then it must include the <code>aModifiesAllChannels</code>
<a href="#Effect::abilities"><code>ability bit</code></a>
to tell the host program to repair modified channels.

<h3><a name="Read Multithreading">Multithreading</a></h3>

<p>If the effect has a user interface, a critical section may be
required to protect internal settings used by the
<code>Read</code> function, the <a href="#PluginObject::Set"><code>Set</code></a>
function, and the <a href="#Page"><code>Page</code></a>
interface.  Effect previewing may make <code>Read</code> calls on
one thread, but call the <a href="#PluginObject::Set"><code>Set</code></a>
function or manage the
<a href="#Page"><code>Page</code></a> interface on a different thread.
Always assume
that settings can and will be changed by the host in the middle of a <code>Read</code>
call and write code accordingly.

<p style="color:#C00000;font-weight:bold">Important:
The effect must never try to modify its user
interface (<a href="#Page"><code>Page</code></a>) during a <code>Read</code> call
since it may be on a different
thread.  It should process the data only.  It must never process waiting
Windows messages, modify control text, enable or disable controls, etc.
Implement the <a href="#Page::Update"><code>Page::Update</code></a>
function for such changes.
</p>

</div>

<h2><a name="Clipboard">Clipboard</a></h2>

<p>Several effects in GoldWave make use of the clipboard for mixing,
modulation (Mechanize), or defining a noise (Noise Reduction).
An effect plug-in can receive clipboard data through its
<a href="#Effect::Input"><code>Input</code></a> member function,
provided it includes the <code>aClipboardRequested</code> or
<code>aClipboardRequired</code>
<a href="#Effect::abilities"><code>ability bit</code></a>.
When the host program sees one of these bits, it passes a Transform
object containing the clipboard audio and the <code>iClipboard</code>
index into the effect's
<code>Input</code> function shortly after it creates the effect and
assigns a source.
If there is no audio in the host program's clipboard at the time the effect
is created, then the <code>Input</code> function is not called.

<p>If the <code>aClipboardRequired</code> ability bit is used, the host
program disables the effect in its menu to prevent the
user from using the effect without clipboard audio.  In other
words, the effect won't be created at all.  If the
<code>aClipboardRequested</code> ability bit is used, the effect itself
must gracefully handle the case when no clipboard audio is
available, by passing back unmodified audio during <code>Read</code>
calls if necessary.

<p>The effect must override its <code>Input</code> member function
to store the Transform pointer so that it can use it later during
<code>Read</code> calls.  The
<a href="#Transform::Reset"><code>Reset</code></a> member function
should be overridden as well to reset the clipboard transform
when the effect itself is reset.

<p>If the <code>Input</code> function returns false, then the effect
does not take ownership of the clipboard object and host
program destroys the clipboard object immediately upon return.  If
the function returns true, then the effect owns the clipboard
object and <b>must</b> destroy
the it when it is no longer needed or when the
effect itself is destroyed.  Note that if the
<code>Input</code> function returns false and
the <code>aClipboardRequired</code> ability bit is set, then processing
fails and the effect is destroyed by the host program.

<p>Use the clipboard's <a href="#Transform::Start"><code>Start</code></a>
and <a href="#Transform::Start"><code>Finish</code></a> functions, if
supported, to determine the length of the clipboard.

<p>The effect must destroy the clipboard transform if it accepts it.


<p><b>Example</b><br>
Demonstrates a simple mixing effect using the clipboard Transform.

<pre>
// Warning: For simplicity this example assumes that the clipboard
// transform has exactly the same sampling rate and number of
// channels as the source transform.
class MixEffect : public Effect
{
protected:
	Transform	*clipboard;

	~MixEffect( void ) { if ( clipboard ) clipboard->Destroy(); }

public:
	MixEffect( void ) { clipboard = 0; }
	unsigned gdecl Ability( void ) { return aClipboardRequired; }
	bool gdecl Input( Transform *transform, int input )
	{
		// Is this the clipboard input?
		if ( input == iClipboard )
		{
			// Destroy any previous clipboard
			if ( clipboard )
			{
				clipboard-&gt;Destroy();
				clipboard = 0;
			}

			// Make sure clipboard rate/channels are the same as the source
			if ( transform-&gt;Rate() == source-&gt;Rate()
				 &amp;&amp; transform-&gt;Channels() == source-&gt;Channels() )
			{
				clipboard = transform;
				return true;
			}
		}
		return false;
	}
	int gdecl Read( audio *buffer, int samples )
	{
		audio	clip[MaxSamples * 2];
		int		process;

		// Read source audio
		samples = source-&gt;Read( buffer, samples );
		// Check for error
		if ( samples &lt; 0 )
			return samples;

		// Make sure the host program provided clipboard audio and read it
		if ( clipboard )
		{
			process = clipboard-&gt;Read( clip, samples );
			// Ignore any clipboard error
			if ( process &lt; 0 )
				return samples;
		}
		else
			process = 0;

		// Mix all samples
		for ( int i = 0; i &lt; process; i++ )
		{
			// Heed warning above.  General mixing is not this simple.
			if ( channel &amp; acfLeft )
				buffer[i * channels] += clip[i * channels];
			if ( (channel &amp; acfRight) &amp;&amp; channels == 2 )
				buffer[i * channels + 1] += clip[i * channels + 1];
		}
		return samples;
	}
	void gdecl Reset( void )
	{
		Effect::Reset();
		// Reset clipboard too
		if ( clipboard )
			clipboard-&gt;Reset();
	}
};
</pre>

<h2><a name="Progress Class">Progress Class</a></h2>

<p>The Progress class provides processing progress information to the
host program and user.  The host program typically displays a window
with a bar indicating what percentage of processing has been completed.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class Progress
{
protected:
	virtual ~Progress();
public:
	virtual void gdecl Destroy( void );
	virtual void gdecl Set( const wchar_t *title, double start, double finish ) = 0;
	virtual void gdecl Show( void ) = 0;
	virtual bool gdecl Update( double position ) = 0;
	virtual void gdecl Hide( void ) = 0;
};
</pre>
<p><b>Purpose</b><br>
Progress objects are derived and created by the host program and used
for <a href="#Effect::Scan">effect scanning</a>.  A plug-in developer does
not need to derive or create these objects, but does need to know
how to use the functions to display meaningful progress information
and to stop processing if the user cancels it.

<p>The effect must call the Progress object's <code>Show</code> function,
then call the <code>Update</code> function
periodically to report its current status only when scanning.  If this function
returns false, the effect <b>must</b> stop scanning.  The <code>Hide</code>
function must be called at the end of processing.

<p>The Progress object <b>must not</b> be used during
<a href="#Transform::Read"><code>Read</code></a> calls.  The host
program may be previewing audio, in which case a progress
window is not needed, or it may be showing its own progress window.
The host program may be using a separate thread for
<a href="#Transform::Read"><code>Read</code></a> calls and deadlock
could result if the Progress object is used on that thread.

<p>The Progress object may be used only during a
<a href="#Effect::Scan">Scan</a> call or when initiated by
the user through a button on the <a href="#Page">Page</a> interface
(such as the Offset effect in GoldWave).

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>~Progress</code>
</td>
<td>
	Protected destructor prevents the effect from accidentally deleting
	the object from its own address space.  Progress objects are created
	in the host program's address space.
</td>
</tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	This function is used by the effect to delete the Progress object
	from the host program's address space.
</td>
</tr>

<tr>
<td valign=top>
	<code>Set</code>
</td>
<td>
	Initializes progress details by assigning a descriptive caption and start
	and finish times.  The caption is displayed in the title bar of
	the progress window.  The start and finish times are used to calculate
	the progress percentage and draw the progress bar.  The effect can
	use sample offsets or times for these values.
</td>
</tr>

<tr>
<td valign=top>
	<code>Show</code>
</td>
<td>
	Tells the host program to display the progress window.
</td>
</tr>

<tr>
<td valign=top>
	<code>Update</code>
</td>
<td>
	Updates the progress to the given position.  This value must be between
	the start and finish values given in the <code>Set</code> function.
	If the value is equal to the start value, then the progress will
	be 0%.  If the value is equal to the finish time, then it will
	be 100%.
	<p>This function returns true if processing should continue normally or
	false if the user pressed the Cancel button.
</td>
</tr>

<tr>
<td valign=top>
	<code>Hide</code>
</td>
<td>
	Tells the host program to hide the progress window.
</td>
</tr>
</table>

<p><b>Example</b><br>
See the <a href="#Scan Example">Scan</a> section below for an example.
</div>

<h2><a name="Effect::Scan">Scan</a></h2>

<p>Some effects must gather statistical information
such as peak amplitude, offset, average volume
level, or frequency content, before it can process the audio.
The <code>Scan</code> function gives the effect a chance
to gather that information and provides a
<a href="#Progress Class">Progress</a> object that the
effect can use to report its scanning progress to the host
program and user.

<div class="in">
<p><b>Declaration</b><br>
<code>bool gdecl Effect::Scan( Progress &amp;progress );</code>

<p><b>Purpose</b><br>
To implement scanning, the <code>Scan</code> function must be overridden
to either scan
the source or store the <code>Progress</code> object for later use.
For example, the Maximize effect in GoldWave scans immediately, while the
Offset set effect allows the user to initiate the scan manually.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Parameter</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>progress</code>
</td>
<td>
	A <a href="#Progress Class">Progress</a> object that the
	effect must use when performing long duration scans (anything
	that would require over one second of time).
</td>
</tr>
</table>

<p>The effect must include the <code>aScanRequested</code> or
<code>aScanRequired</code>
<a href="#Effect::abilities"><code>ability bit</code></a> to enable
scanning.  When the host program sees that bit, it will create a derived
<a href="#Progress Class"><code>Progress</code></a> object, then call the
<code>Scan</code> function, passing the <code>Progress</code> object.
See the <a href="#Effect Host Program Usage">Host Program Usage</a>
section for information about when the host program uses the
<code>Scan</code> function.

<p>Scanning is done by making source
<a href="#Transform::Read"><code>Read</code></a>
calls until 0 is returned.  The
<a href="#Transform::Reset"><code>Reset</code></a> function <b>must</b>
be called after scanning is complete.  If the source is not reset,
then the <code>Read</code> function will fail when called by the host program.

<p>The function returns true if successful or false if processing
must be aborted due to an error or by the user.

<p>The effect owns the <code>Progress</code> object
and <b>must</b> destroy it when
it is no longer needed by calling its <code>Destroy</code> member
function.  This must be done regardless if scanning is successful
or fails (such as when the <code>Scan</code> function returns false).

<p><a name="Scan Example"><b>Example</b></a><br>
<pre>
bool Maximize::Scan( Progress &amp;progress )
{
	audio	buffer[MaxSamples * 2];
	int	samples;
	bool	abort = false;

	progress.Set( L"Scan Caption", source-&gt;Start(), source-&gt;Finish() );
	progress.Show();
	while ( (samples = source-&gt;Read( buffer, MaxSamples)) &gt; 0 &amp;&amp; ! abort )
	{
		// Process samples to gather information...

		// Update progress
		if ( ! progress.Update( source-&gt;Time() ) )
			abort = true;
	}
	progress.Show();
	source-&gt;Reset();
	progress.Destroy();

	return ! abort;
}
</pre>

</div>


<h2><a name="Effect Host Program Usage">Host Program Usage</a></h2>

<p>The host program loads the Effect module then calls the
<a href="#Interface Function">Interface Function</a> to get a pointer to
the <a href="#Interface Structure">Interface Structure</a>.

<p>The host program performs the following steps when creating
and using an effect:
<ol>
<li> It checks the bits in the <a href="#Effect::abilities"><code>abilities</code></a>
in the <a href="#Interface::list"><code>Interface::list</code></a> table to
ensure all bits can be supported and that the source transform is compatible.
<li> It calls the <a href="#Interface::create"><code>Interface::create</code></a>
function to create the effect object based on its
<a href="#Effect::name"><code>name</code></a>
in the <a href="#Interface::list"><code>Interface::list</code></a> table.

<li> It calls the <a href="#Transform::Source"><code>Source</code></a> to
assign a source.
<li> If the <code>aClipboardRequested</code> or
<code>aClipboardRequired</code> ability bit is set, it creates and
passes a clipboard Transform object to the effect's
<a href="#Effect::Input"><code>Input</code></a> function.
If that function returns false, the clipboard object is destroyed.  If the
<code>aClipboardRequired</code> ability bit is set, processing
is aborted and the effect is destroyed.  Otherwise the
effect must continue without clipboard audio.  If the function returns
true, then the effect is responsible for destroying the clipboard object
later.
<li> If the <code>aScanRequested</code> or
<code>aScanRequired</code> ability bit is set, it creates a derived
<a href="#Progress Class"><code>Progress</code></a>
object and calls the <a href="#Effect::Scan"><code>Scan</code></a>
function passing the <code>Progress</code> object.  The effect
is responsible for destroying the <code>Progress</code> object
later, regardless if scanning succeeds or fails.
<li> If the <code>aPage</code>
<a href="#Effect::abilities"><code>ability</code></a>
is set, it may call the
<a href="#PluginObject::Set"><code>Set</code></a>
function to set any default setting or preset settings.
<li> If the <code>aPage</code>
<a href="#Effect::abilities"><code>ability</code></a>
is set, it may call the
<a href="#PluginObject::GetPage"><code>GetPage</code></a> function
and host the effect's window in its own window.  Otherwise,
the effect is processed immediately and destroyed.
<li> If the user previews the effect, it makes calls on a new
thread to the <a href="#Transform::Read"><code>Read</code></a>
function until 0 samples are returned or the
users stops previewing.  It then calls the
<a href="#Transform::Reset"><code>Reset</code></a> function.
This step may be repeated many times.
<li> If the user OKs the effect, similar processing
occurs, but the effect is destroyed at the end.
<li> If the user cancels the effect, the effect is destroyed.
</ol>

<h1><a name="File Format Plug-ins">File Format Plug-ins</a></h1>

<p>File Format plug-ins decode and encode audio to and from a common
<a href="#audio Type">audio</a> format.  They can add support
for new, custom, or proprietary file formats to GoldWave.  A
File Format plug-in may provide the ability to read and decode
audio, write and encode audio, or both read and write, depending
on its <a href="#AudioFile::abilities">abilities</a>.  The
plug-in is divided into threes sets of functions: the first set handles
reading, the second set handles writing, and the last set handles
format information.  The reading related functions are
<code>Open</code>, <code>Read</code>, <code>Seek</code>,
<code>Length</code>, <code>Close</code>, and <code>GetFormat</code>.
The writing related functions are
<code>Begin</code>, <code>Write</code>, and <code>End</code>.
The format related functions are <code>GetFormat</code> and
<code>Formats</code>.

<p>File Format plug-ins typically require much more programming
than the other plug-in classes.  More member functions must
be overridden and more derived classes are required.

<p>File Format related classes belong to the <code>Gap</code> (<b>G</b>oldWave
<b>A</b>udio <b>P</b>lug-in) namespace.

<h2><a name="AudioFile Class">AudioFile Class</a></h2>
<p>File Format plug-ins derive classes from the <code>AudioFile</code> class
to support specific file types.  With each derived
<code>AudioFile</code> class a derived <a href="#Format Class">Format</a>
class may be required as well.  A File Format plug-in module
must implement at least one <code>AudioFile</code> class
and at least one <a href="#Format Class">Format</a> class.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class AudioFile : public Gbase::PluginObject
{
protected:
	Asker		*asker;
	Metadata	*metadata;

	virtual		~AudioFile( void );
	int		Ask( const wchar_t *message, int options, int def );
public:
	AudioFile( void );
	virtual void gdecl		Destroy( void );
	virtual Gerr::Error gdecl	Open( const wchar_t *name, const Format *format = 0 ) = 0;
	virtual int gdecl		Read( audio *buffer, int samples ) = 0;
	virtual Gerr::Error gdecl	Seek( int64 start ) = 0;
	virtual Gerr::Error gdecl	Close( void ) = 0;
	virtual int64 gdecl		Length( void ) = 0;
	virtual Gerr::Error gdecl	UpdateInfo( bool force );
	virtual Gerr::Error gdecl	Begin( const wchar_t *name, const Format &amp;format ) = 0;
	virtual Gerr::Error gdecl	Write( const audio *buffer, int samples ) = 0;
	virtual Gerr::Error gdecl	End( void ) = 0;
	virtual FormatList * gdecl	Formats( void ) = 0;
	virtual Format * gdecl		GetFormat( void ) = 0;
	virtual Metadata * gdecl  	GetMetadata( void );
	virtual Asker * gdecl	  	GetAsker( void );
	virtual void gdecl 		Setup( Metadata *Data, Asker *Asker );
	virtual Gerr::Error gdecl	ReadFrame( double time, Gvp::Pixel *frame, Frame *info = 0 );
	virtual Gerr::Error gdecl	WriteFrame( double time, const Gvp::Pixel *frame, const Frame *info = 0 );
};
</pre>
<p><b>Purpose</b><br>

This is the base class for all File Format plug-ins.  To create a plug-in,
derive a class from this one.  Refer to the
<a href="#PluginObject">PluginObject</a> section for other member functions.
These member functions must be overriden for any plug-in:
<ul>
<li> <a href="#PluginObject::Ability"><code>PluginObject::Ability</code></a>
<li> <a href="#PluginObject::Name"><code>PluginObject::Name</code></a>
</ul>

<p>For a plug-in that reads files, the following functions must be implemented:
<ul>
<li> <a href="#AudioFile::Open"><code>AudioFile::Open</code></a>
<li> <a href="#AudioFile::Read"><code>AudioFile::Read</code></a>
<li> <a href="#AudioFile::ReadFrame"><code>AudioFile::ReadFrame</code></a>
<li> <a href="#AudioFile::Seek"><code>AudioFile::Seek</code></a>
<li> <a href="#AudioFile::Close"><code>AudioFile::Close</code></a>
<li> <a href="#AudioFile::Length"><code>AudioFile::Length</code></a>
<li> <a href="#AudioFile::GetFormat"><code>AudioFile::GetFormat</code></a>

</ul>

<p>For a plug-in that writes files, the following functions must be implemented:
<ul>
<li> <a href="#AudioFile::Begin"><code>AudioFile::Begin</code></a>
<li> <a href="#AudioFile::Write"><code>AudioFile::Write</code></a>
<li> <a href="#AudioFile::WriteFrame"><code>AudioFile::WriteFrame</code></a>
<li> <a href="#AudioFile::End"><code>AudioFile::End</code></a>
<li> <a href="#AudioFile::Formats"><code>AudioFile::Formats</code></a>
<li> <a href="#AudioFile::GetFormat"><code>AudioFile::GetFormat</code></a>
</ul>

For a plug-in that provides a graphical interface where the user can specify
format settings directly, the following function must be overridden:
<ul>
<li> <a href="#PluginObject::GetPage"><code>PluginObject::GetPage</code></a>
<li> <a href="#PluginObject::Get"><code>PluginObject::Get</code></a>
<li> <a href="#PluginObject::Set"><code>PluginObject::Set</code></a>
</ul>

All pure functions that do not need to be implemented still need to
be defined to return the
<a href="#Error Codes"><code>Gerr::eUnsupported</code></a> error code.
For example,
if only reading functionality is implemented, then all the
writing funtions must return the error.


<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>asker</code>
</td>
<td>
	A pointer to an <a href="#Asker Class"><code>Asker</code></a> object
	that the host program assigns to the plug-in.  The plug-in does
	not need to use this directly.  It should use the <code>Ask</code>
	member function instead.  The host program owns this object.
</td>
</tr>

<tr>
<td valign=top>
	<code>metadata</code>
</td>
<td>
	A pointer to a <a href="#Metadata Class"><code>Metadata</code></a> object
	that the host program assigns to the plug-in for storing non-audio
	information in the file, such as artist, copyright, title, cue point, cover art, etc.
	The plug-in must check that this is not 0 before
	using it.  The host program assigns this through the
	<a href="#AudioFile::Setup"><code>Setup</code></a> member function.
	The host program owns this object.
</td>
</tr>

<tr>
<td valign=top>
	<code>~AudioFile</code>
</td>
<td>
	Protected destructor prevents host program from accidentally deleting
	object from its own address space.
</td>
</tr>

<tr>
<td valign=top>
	<code>Ask</code>
</td>
<td>
	Function for simplifying the use of the
	<a href="#Asker Class"><code>Asker</code></a>
	object.  This function should be used rather than using
	the <a href="#Asker Class"><code>Asker</code></a> object
	directly.  The function may be used only within an
	<a href="#AudioFile::Open">Open</a> call.
</td>
</tr>

<tr>
<td valign=top>
	<code>AudioFile</code>
</td>
<td>
	Constructor to initialize member variables.
</td>
</tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	This function is used by the host program to destroy the plug-in
	and delete it from the module's address space.  This
	function should not be overridden.
</td>
</tr>

<tr>
<td valign=top>
	<code>Open</code>
</td>
<td>
	Opens an input file with the given filename using the optional format
	information (for raw/headerless file where the format cannot
	be determined automatically).  See
	<a href="#AudioFile::Open">Open</a> for more information.
</td>
</tr>

<tr>
<td valign=top>
	<code>Read</code>
</td>
<td>
	Reads audio data from the input file and decodes or converts it into the
	<a href="#audio Type"><code>audio</code></a> format, passing back
	the requested number of	<a href="#Sample">samples</a>
	to the host program.
	See <a href="#AudioFile::Read">Read</a> for more information.
</td>
</tr>

<tr>
<td valign=top>
	<a name="AudioFile::ReadFrame"><code>ReadFrame</code></a>
</td>
<td>
	Reads the video frame from the file at the given time.  The image is
	stored in the given frame pointer as 32-bit ARGB
	<a href="#Pixel Structure">pixels</a>.  If the frame point is
	null, only the frame info is returned so that the application can allocate sufficient memory.
	to store the frame.
	The frame info contains the frame rate and frame size.  The frame info pointer may be
	null provided the frame pointer is not null.  Otherwise return
	<a href="#Error Codes"><code>Gerr::eParameter</code></a>.  If the frame info pointer is not
	null, then all the frame info must be set.
</td>
</tr>

<tr>
<td valign=top>
	<code>Seek</code>
</td>
<td>
	Seeks to an exact sample position within the file.  This is
	the sample position with respect to decoded samples from
	the beginning of the file and not a byte offset.
	See	<a href="#AudioFile::Seek">Seek</a> for more information.
</td>
</tr>

<tr>
<td valign=top>
	<code>Close</code>
</td>
<td>
	Closes the input file only.  This must not affect the output file
	for writing.
	See	<a href="#AudioFile::Close">Close</a> for more information.
</td>
</tr>

<tr>
<td valign=top>
	<a name="AudioFile::Length"><code>Length</code></a>
</td>
<td>
	Returns the exact number of decoded samples contained in the file.
	If this value cannot be determined quickly, without decoding the
	entire file, then the best estimate must be returned and the
	format object associated with the file (and returned by
	<a href="#AudioFile::GetFormat"><code>GetFormat</code></a>)
	must have the
	<code>fUnsized</code> <a href="#Format::Flags"><code>flag</code></a> set.
</td>
</tr>

<tr>
<td valign=top>
	<code>UpdateInfo</code>
</td>
<td>
	Updates the cue points and file information of the opened
	file without re-encoding/re-saving the entire file.  If the
	entire file must be recreated to make room for
	the information, then this function must return
	<a href="#Error Codes"><code>Gerr::eParameter</code></a> unless
	the <code>force</code> parameter is true.  If the plug-in does
	not support this function, it must return
	<a href="#Error Codes"><code>Gerr::eUnsupported</code></a>.
	This function is not used by GoldWave yet.
</td>
</tr>

<tr>
<td valign=top>
	<code>Begin</code>
</td>
<td>
	Creates an output file and prepares the plug-in for writing and
	encoding in the given format.
	See <a href="#AudioFile::Begin">Begin</a> for more information.
</td>
</tr>

<tr>
<td valign=top>
	<code>Write</code>
</td>
<td>
	Encodes or converts the given number of
	<a href="#audio Type"><code>audio</code></a>
	<a href="#Sample">samples</a> and
	stores them in the file.
	See	<a href="#AudioFile::Write">Write</a> for more information.
</td>
</tr>

<tr>
<td valign=top>
	<a name="AudioFile::WriteFrame"><code>WriteFrame</code></a>
</td>
<td>
	Writes the video frame to the file at the given time.  The image is
	stored in the given frame pointer as 32-bit ARGB
	<a href="#Pixel Structure">pixels</a>.
	The frame info contains the frame rate and frame size.  The frame info pointer may be
	null if the frame rate and size has not changed.  Otherwise return
	<a href="#Error Codes"><code>Gerr::eParameter</code></a>.  If variable frame rates or frame
	sizes are not supported, then <a href="#Error Codes"><code>Gerr::eUnsupported</code></a>
	should be returned.  The application must provide frame info on its initial call.
</td>
</tr>

<tr>
<td valign=top>
	<code>End</code>
</td>
<td>
	Writes any final file structure information and audio data and closes
	the output file.  This must not affect the input file.
	See	<a href="#AudioFile::End">End</a> for more information.
</td>
</tr>

<tr>
<td valign=top>
	<code>Formats</code>
</td>
<td>
	Returns a <a href="#FormatList Class"><code>FormatList</code></a>
	pointer which is a list of formats
	supported by this plug-in, if the plug-in supports file writing.
	This list is given in
	the Attributes drop down list under GoldWave's <b>File | Save As</b>
	command.  See
	<a href="#AudioFile::Formats"><code>Formats</code></a> for
	more information.
	<p>The host program owns the list and will destroy
	it when it is no longer needed.
</td>
</tr>

<tr>
<td valign=top>
	<code>GetFormat</code>
</td>
<td>
	Returns a Format pointer describing the current format of
	the input file.  If no file is opened, then it returns the
	best default format to use for creating a file with this
	plug-in, if the plug-in supports file writing.  If the plug-in
	provides a page for custom settings, then that format
	is returned.  See
	<a href="#AudioFile::GetFormat"><code>GetFormat</code></a> for
	more information.
	<p>The host program owns the object and will destroy
	it when it is no longer needed.
</td>
</tr>

<tr>
<td valign=top>
	<code>GetMetadata</code>
</td>
<td>
	Returns a pointer to the <a href="#Metadata Class"><code>Metadata</code></a>
	object.
</td>
</tr>

<tr>
<td valign=top>
	<code>GetAsker</code>
</td>
<td>
	Returns a pointer to the <a href="#Asker Class"><code>Asker</code></a>
	object.
</td>
</tr>

<tr>
<td valign=top>
	<a name="AudioFile::Setup"><code>Setup</code></a>
</td>
<td>
	Allows the host program to set the
	<a href="#Metadata Class"><code>Metadata</code></a> and
	<a href="#Asker Class"><code>Asker</code></a> objects to be
	used by the plug-in.
</td>
</tr>

</table>
</div>

<h2><a name="Format Class">Format Class</a></h2>
<p>The Format class helps the host program determine the format of
an input file or set the format for an output file without having any
specific knowledge about the file type or format itself.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class Format
{
protected:
	virtual ~Format( void );
public:
	void *programdata;
	Format( void );
	virtual void gdecl		Destroy( void );
	virtual Gerr::Error gdecl	SetChannels( int channels ) = 0;
	virtual Gerr::Error gdecl	SetRate( int rate ) = 0;
	virtual Gerr::Error gdecl	SetBitrate( int bitrate ) = 0;
	virtual unsigned gdecl		Flags( void ) const = 0;
	virtual int gdecl		Channels( void ) const = 0;
	virtual int gdecl		Rate( void ) const = 0;
	virtual int gdecl		Bitrate( void ) const = 0;

	virtual bool gdecl		operator==( const Format &amp;format ) const = 0;
	virtual Format * gdecl		Duplicate( void ) const = 0;
	virtual const wchar_t * gdecl	Type( void ) const = 0;
	virtual const wchar_t * gdecl	Description( void ) = 0;
	virtual const wchar_t * gdecl	Extension( void ) const = 0;
};
</pre>

<p><b>Purpose</b><br>
<p>This class provides format information to the host program and
allows the host program to change the format in a number of ways.
All File Format plug-ins must have their own derived Format class to
mediate format settings between the plug-in and the host program.
If a plug-in module supports several different file types, then
several different derived Format classes may be required.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>~Format</code>
</td>
<td>
	Protected destructor prevents host program from accidentally deleting
	object from its own address space.
</td>
</tr>

<tr>
<td valign=top>
	<code>programdata</code>
</td>
<td>
	This is a pointer the host program may use to associate additional
	data with the format object.  Plug-in developers <b>must not</b> use
	this member in any way.
</td>
</tr>

<tr>
<td valign=top>
	<code>Format</code>
</td>
<td>
	Constructor to initializes the <code>programdata</code> member
	to 0.  The constructor should setup a default format in derived classes.
</td>
</tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	This function is used by the host program to destroy the Format
	object and delete it from the module's address space.  This
	function should not be overridden.
</td>
</tr>

<tr>
<td valign=top>
	<code>SetChannels</code>
</td>
<td>
	The host program calls this function to set the number of channels
	for the output format.  The function returns the
	<a href="#Error Codes"><code>Gerr::eUnsupported</code></a> error
	if the number of channels cannot be supported.
</td>
</tr>

<tr>
<td valign=top>
	<code>SetRate</code>
</td>
<td>
	The host program calls this function to set the
	<a href="#Sampling Rate">sampling rate</a>
	for the output format.  The function returns the
	<a href="#Error Codes"><code>Gerr::eUnsupported</code></a> error
	if the rate cannot be supported.
</td>
</tr>

<tr>
<td valign=top>
	<code>SetBitrate</code>
</td>
<td>
	The host program calls this function to set the
	<a href="#Bitrate">bitrate</a>
	for the output format.  The function returns the
	<a href="#Error Codes"><code>Gerr::eUnsupported</code></a> error
	if the bitrate cannot be supported.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Format::Flags"><code>Flags</code></a>
</td>
<td>
	Returns the flags for the format.  Flags are local to the
	Format object and may require the <code>Gap::Format::</code>
	scope specifier if used outside of the Format class.

	<p><table align="center" border="0" width="100%" cellpadding=2>
	<tr><th align=left>Flag</th><th align=left>Purpose</th></tr>

	<tr><td valign=top>fDefault</td><td>Tells the host program
	that this is the default format and it should be selected by default
	when the FormatList is shown to the user.</td></tr>

	<tr><td valign=top>fVBR</td><td>Tells the host program that this
	is a variable bitrate format.</td></tr>

	<tr><td valign=top>fAnyRate</td><td>Tells the host program that any
	sampling rate is supported by the format.</td></tr>

	<tr><td valign=top>fSequential</td><td>Tells the host program that seeking
	is not allowed and that the file must be read sequentially.</td></tr>

	<tr><td valign=top>fBeyond4GB</td><td>Tells the host program that the
	file format can support files larger than 4GB.</td></tr>

	<tr><td valign=top>fUnsized</td><td>Tells the host program that the
	exact number of samples in the encoded file cannot be determined with
	this file or format.</td></tr>

	</table>

</td>
</tr>

<tr>
<td valign=top>
	<code>Channels</code>
</td>
<td>
	Returns the number of channels associated with the format.
</td>
</tr>

<tr>
<td valign=top>
	<code>Rate</code>
</td>
<td>
	Returns the <a href="#Sampling Rate">sampling rate</a> of the format.
</td>
</tr>

<tr>
<td valign=top>
	<code>Bitrate</code>
</td>
<td>
	Returns the <a href="#Bitrate">bitrate</a> of the format.
</td>
</tr>

<tr>
<td valign=top>
	<code>operator&nbsp;==</code>
</td>
<td>
	Returns true if this format is identical to the given format.
	The bitrate, sampling rate, number of channels, encoding format,
	etc. all must match and the given format object must belong to this plug-in
	(it must have been created by this plug-in's module).
	The host program uses this function to select the closest matching
	format from a <a href="#FormatList Class">FormatList</a>.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Format::Duplicate"><code>Duplicate</code></a>
</td>
<td>
	Makes an exact copy of this format and returns a pointer
	to the copy.  The host program owns the object and must
	destroy it later.
</td>
</tr>

<tr>
<td valign=top>
	<code>Type</code>
</td>
<td>
	Returns a string describing the type of the format.
</td>
</tr>

<tr>
<td valign=top>
	<code>Description</code>
</td>
<td>
	Returns a string describing encoding algorithm, sampling rate,
	bitrate, number of channels, byte ordering, signed/unsigned,
	or other details about the format.  If any <code>Set...</code>
	calls were made on the format object, then the description
	must reflect those changes.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Format::Extension"><code>Extension</code></a>
</td>
<td>
	Returns a string containing the most appropriate filename extension
	for this format.  This must be all lowercase without a leading
	dot, such as "wav" or "mp3".  The host program will append this
	string to the end of the filename, inserting the dot as needed.
</td>
</tr>

</table>
</div>

<h2><a name="List Class">List Class</a></h2>
<p>The List base class is used to store a list of Format objects or a list
of cue points.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class List
{
protected:
	virtual			~List( void );
	int			count;
	virtual void gdecl	Destroy( void );

public:
	List( void );
	int gdecl 		Count( void ) const;
};
</pre>

<p><b>Purpose</b><br>
<p>This base class provides similar list functionality for list objects
used in the File Format plug-in interface.  It essentially returns
a count of items and protects the destructor.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>~List</code>
</td>
<td>
	Protected destructor prevents host program from accidentally deleting
	object from its own address space.
</td>
</tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	This function is used by the host program to destroy the List
	object and delete it from the module's address space.  This
	function should not be overridden.
</td>
</tr>

<tr>
<td valign=top>
	<code>count</code>
</td>
<td>
	Number of items in the list.  The host program uses the <code>Count</code>
	member function to retrieve this number.  Any derived classes are
	responsible for updating this number.
</td>
</tr>

<tr>
<td valign=top>
	<code>List</code>
</td>
<td>
	Constructor to initialize <code>count</code> member.
</td>
</tr>

<tr>
<td valign=top>
	<code>Count</code>
</td>
<td>
	Returns the <code>count</code> value.
</td>
</tr>
</table>
</div>

<h2><a name="FormatList Class">FormatList Class</a></h2>
<p>The FormatList class stores a list of <a href="#Format Class">Format</a>
objects supported
by the File Format plug-in.  The host program uses this
list to automatically select or allow the user to select a format
to use in the <a href="#AudioFile::Begin">Begin</a> function when
creating a file for writing. 

<div class="in">
<p><b>Declaration</b><br>
<pre>
class FormatList : public <a href="#List Class">List</a>
{
public:
		virtual void gdecl Destroy( void );
		virtual Format * gdecl operator[]( int n ) = 0;
};
</pre>

<p><b>Purpose</b><br>
This class adds a <a href="#Format Class">Format</a> subscript
indexer to the List base class.
The FormatList must contain 0 to <code>count</code> - 1
<a href="#Format Class">Format</a> objects.  The FormatList
owns all the Format objects and must destroy them when the
list itself is destroyed by the host program.

<p>The host program may modify any of the
<a href="#Format Class">Format</a> objects by using one of the
<code>Set...</code> calls, so pointers to copies of the
<a href="#Format Class">Format</a> object must be stored
rather than static/global pointers.

A File Format plug-in developer must derive a class from this
so that it can return its own FormatList pointer when the host
program calls the
<a href="#AudioFile::Formats"><code>AudioFile::Formats</code></a>
function.


<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	This function is used by the host program to destroy the FormatList
	object and delete it from the module's address space.  This
	function should not be overridden.  The derived list destructor
	must free any Format objects contained in the list.
</td>
</tr>

<tr>
<td valign=top>
	<a name="FormatList::index"><code>operator&nbsp;[]</code></a>
</td>
<td>
	Returns a pointer to the Format object in the list with the given
	subscript index or 0 if the index is out of range.  This is a
	pure virtual function and must be implemented.  This host program
	uses this function to list formats or select a certain format.
</td>
</tr>
</table>
</div>

<h2><a name="Metadata Class">Metadata Class</a></h2>
<p>The Metadata class is a container to hold all non-audio information in the file, including:
<ul>
	<li><a href="#Metadata Text Class">Text</a> information such as title, artist, and copyright
	<li><a href="#Metadata CueList Class">Cue points</a>
	<li><a href="#Metadata PictureList Class">Cover art</a>
	<li>Loop points
	<li><a href="#Metadata Raw Class">Raw</a> or custom information
</ul>

<p>The host program creates, destroys, and owns this object.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class Metadata
{
protected:
	virtual ~Metadata( void );
public:
	class Data
	{
	protected:
		virtual ~Data( void );
	public:
		virtual void gdecl Destroy( void );
		virtual Data * gdecl Duplicate( void ) const = 0;
	};

	virtual void gdecl	Destroy( void );
	virtual Data * gdecl	New( const wchar_t *name, int size = 0 ) = 0;
	virtual bool gdecl	Set( const wchar_t *name, Data *data, bool copy = false ) = 0;
	virtual Data * gdecl	Get( const wchar_t *name, bool create = false ) = 0;

	virtual bool gdecl		SetText( const wchar_t *name, const wchar_t *text ) = 0;
	virtual const wchar_t * gdecl	GetText( const wchar_t *name ) = 0;
};
</pre>

<p><b>Purpose</b><br>
The File Format plug-in uses this container object to hold non-audio information within
the file when reading a file or to save the information when writing a file.
The plug-in must use the <code>aMetaText</code>, <code>aMetaCue</code>, <code>aMetaPicture</code>
<a href="#AudioFile::abilities"><code>abilities</code></a> to
indicate to the host program that it supports file information.

<p>The host program creates a derived class to manage the metadata.
A File Format plug-in developer must not derive a class from
this one.  Instead, it must use the <code>Metadata</code> object assigned by
host program through the
<a href="#AudioFile::Setup"><code>Setup</code></a> call.

<p>When opening a file, all the metadata
must be stored in the metadata class in the <a href="#AudioFile::Open"><code>Open</code></a>
function. Do not add metadata in the <a href="#AudioFile::Read"><code>Read</code></a> function.

<p>When saving a file, write the metadata in the <a href="#AudioFile::End"><code>End</code></a> function
if possible because information may be added by the host program during writing.  Writing metadata
in the <a href="#AudioFile::Begin"><code>Begin</code></a> function is permitted, but it may not have the complete
data.  The <b>File Merger</b> tool in GoldWave, for example, adds cue points to the metadata
for each merged file during writing, so the plug-in will not have complete data within the
<a href="#AudioFile::Begin"><code>Begin</code></a> call.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>~Metadata</code>
</td>
<td>
	Protected destructor.  The host program deletes the object and destroys all the metadata contained
	within.
</td>
</tr>

<tr>
<td valign=top>
	<a href="#Metadata Data Class"><code>class&nbsp;Data</code></a>
</td>
<td>
	The base class for all non-audio data.  Other classes are derived from this one, such as
	<a href="#Metadata CueList Class"><code>Gmd::CueList</code></a> for cue points and
	and <a href="#Metadata Text Class"><code>Gmd::Text</code></a> for text information.
</td>
</tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
        The host program owns the Metadata object.  The plug-in must not delete
        or destroy it.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Metadata::New"><code>New</code></a>
</td>
<td>
	Creates a new object derived from <a href="#Metadata Data Class"><code>Data</code></a> based
	on the name provided.  Names are listed in the <code>gwmetadata.h</code> file.
	If the name <code>GWText_Title</code> is given, a
	<a href="#Metadata Text Class"><code>Gmd::Text</code></a> object is created.  If
	the name <code>GWRaw</code> is given with a size, a
	<a href="#Metadata Text Class"><code>Gmd::Raw</code></a> object of that size is created.
	The <a href="#Metadata::Set"><code>Set</code></a> function is used to add (or replace) a data
	object in the metadata.  See the example below.
	Plug-in developers should use the <a href="#Metadata::Get"><code>Get</code></a> function
	to easily create and add a standard data object to the metadata.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Metadata::Set"><code>Set</code></a>
</td>
<td>
	Adds the named data to the metadata.  Names are listed in the <code>gwmetadata.h</code> file.
	The <code>copy</code> value must be <code>true</code> if a temporary <code>Data</code> object
	is being passed or if the <code>Data</code> will be reused for some other purpose later.  It
	should be <code>false</code> if the metadata takes complete owership of the object.  See the following
	example.

<p><b>Example</b><br>
<pre>
if ( metadata )
{
	Gmd::Text *text = (Gmd::Text *)metadata->New( Gmd::GWText );

	*text = L"Copyright &copy; 2009 GoldWave Inc.";
	metadata-&gt;Set( Gmd::GWText_Copyright, text, false );
	*text = L"GoldWave Inc.";
	metadata-&gt;Set( Gmd::GWText_Author, text, true );	// metadata now owns text
	// text-&gt;Destroy() is not necessary now that metadata owns it	
}
</pre>

	<p>The <a href="#Metadata CueList Class"><code>Gmd::CueList</code></a> object cannot be set in GoldWave.
	Any attempt to do so will fail.  Plug-in developers should use the 
	the <a href="#Metadata::Get"><code>Get</code></a> function to retrieve the cue points data object
	and update it as required.
</td>
</tr>

<tr>
<td valign=top>
	<a name="Metadata::Get"><code>Get</code></a>
</td>
<td>
	Retrives the named data in the metadata, if it is present.  Returns 0 if it is not present
	and <code>create</code>
	is false.  Names are listed in the <code>gwmetadata.h</code> file.  If <code>create</code> is true,
	then the object is created and added to the metadata object and the pointer is returned.
	
<p><b>Example</b><br>
<pre>
if ( metadata )
{
	// Gets the author data or creates it if it doesn't exist yet
	Gmd::Text *author = (Gmd::Text *)metadata-&gt;Get( Gmd::GWText_Author, true );
	if ( author )
	{
		// Display the text using a Windows function
		::SetWindowText( hwindow, *author );
	
		// Sets the author data in the metadata directly
		*author =  L"GoldWave Inc.";

		// Sets it as ANSI
		author-&gt;Set( "GoldWave Inc.", Gmd::Ansi );
	}
}
</pre>
</td>
</tr>

<tr>
<td valign=top>
	<a name="Metadata::SetText"><code>SetText</code></a>
</td>
<td>
	Provides a quick way to set the named text information in metadata.
	Names are listed in the <code>gwmetadata.h</code> file.  
	
<p><b>Example</b><br>
<pre>
if ( metadata )
	metadata-&gt;SetText( Gmd::GWText_Author, L"GoldWave Inc." );
</pre>
</td>
</tr>

<tr>
<td valign=top>
	<a name="Metadata::GetText"><code>GetText</code></a>
</td>
<td>
	Provides a quick way to get the named text information from metadata.  Returns 0 if the named text
	information is not present.  Names are listed in the <code>gwmetadata.h</code> file.  
	
<p><b>Example</b><br>
<pre>
const wchar_t	*author;
if ( metadata )
	*author = metadata-&gt;GetText( Gmd::GWText_Author );
</pre>
</td>
</tr>
</table>


<h3><a name="Metadata Data Class">Data Class</a></h3>
<p>This is the base class for a piece of data in the metadata container.  Derived classes are explained in the
following sections.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class Metadata::Data
{
protected:
	virtual ~Data( void );
public:
	virtual void gdecl Destroy( void );
	virtual Data * gdecl Duplicate( void ) const = 0;
};
</pre>

<p><b>Purpose</b><br>
The Metadata Data object is a generic piece of data.  It can be text, an image, a list of cue points, etc.  All
data stored in the metadata container are derived from this class.  Data objects supported by the Host program
should be created or retrieved by using <a href="#Metadata::New"><code>Metadata::New</code></a> or the
<a href="#Metadata::Get"><code>Metadata::Get</code></a>.  Classes and names for specific forms of Data are
listed in <code>gwmetadata.h</code>.


<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>~Data</code>
</td>
<td>
	Protected destructor to ensure object is deleted from originating module.
</td>
</tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	The <a href="#Metadata Class">Metadata</a> class calls this function to delete the object from
	the originating module.  Usually this member does not have to be overridden.
</td>
</tr>

<tr>
<td valign=top>
	<code>Duplicate</code>
</td>
<td>
	Creates an exact, deep copy of the object.  The copy must not depend on the original data in
	any way.  The copy or the original may be destroyed at any time, so they must exist
	independently.
</td>
</tr>

</table>
</div>

<h3><a name="Metadata Text Class">Text Class</a></h3>
<p>The Text data class stores text information.  This class resides in the
<code>Gmd</code> namespace in <code>gwmetadata.h</code>.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class Text : public <a href="#Metadata Data Class">Gap::Metadata::Data</a>
{
public:
	virtual Data * gdecl Duplicate( void ) const = 0;
        virtual gdecl operator const wchar_t *( void ) const = 0;
        virtual Text &amp; gdecl operator=( const wchar_t *string ) = 0;
        virtual bool gdecl Set( char *string, int encoding ) = 0;
        virtual const char * gdecl Get( int encoding ) = 0;
};
</pre>

<p><b>Purpose</b><br>
The Text class holds text information about a file, such as the artist, author, title, copyright, etc.
The <code>Set</code> and <code>Get</code> conversion functions support ANSI and UTF-8 text.  If text is
unicode, then the <a name="Metadata::SetText"><code>Metadata::SetText</code></a> and
the <a name="Metadata::GetText"><code>Metadata::GetText</code></a> functions can be used to simplify
code.  Text information supported by GoldWave is listed in <code>gwmetadata.h</code>
and prefixed with <code>GWText_</code>.

<p>To create a Text data object, use the <a href="#Metadata::Get"><code>Metadata::Get</code></a>
function with <code>create</code> set to true to obtain a Text data object.  The  function
automatically finds the existing information, if present, or creates a new one and adds it to
the metadata container.  If a new, generic Text data object is required, use
the <a href="#Metadata::New"><code>Metadata::New</code></a> function with the
<code>Gmd::GWText</code> name.  Use <a href="#Metadata::Set"><code>Metadata::Set</code></a>
later to add it to the metadata container using a specific name.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>Duplicate</code>
</td>
<td>
	Creates an exact, deep copy of the text.  The copy must not depend on the original data in
	any way.  The copy or the original may be destroyed at any time, so they must exist
	independently.
</td>
</tr>

<tr>
<td valign=top>
	<code>operator const wchar_t *</code>
</td>
<td>
	Returns a pointer to the unicode string.  This string must not be modified.
</td>
</tr>

<tr>
<td valign=top>
	<code>operator=</code>
</td>
<td>
	Assigns a new string to the Text object.
</td>
</tr>

<tr>
<td valign=top>
	<code>Set</code>
</td>
<td>
	Converts an ANSI or UTF-8 string to unicode and assigns it to the Text object.  <code>encoding</code>
	is either <code>Gmd::Ansi</code> or <code>Gmd::Utf8</code>.
</td>
</tr>

<tr>
<td valign=top>
	<code>Set</code>
</td>
<td>
	Converts a Text object to an ANSI or UTF-8 string.  <code>encoding</code>
	is either <code>Gmd::Ansi</code> or <code>Gmd::Utf8</code>.
</td>
</tr>

</table>
</div>

<h3><a name="Metadata CueList Class">CueList Class</a></h3>
<p>The CueList data class holds information about all the cue points in
a file.  Both the <code>Cue</code> and <code>CueList</code> classes reside
in the <code>Gmd</code> namespace in <code>gwmetadata.h</code>.

<div class="in">
<p><b>Declaration</b><br>
<pre>
struct Cue
{
	double		position;
	const wchar_t	*name, *description;
	Cue( void )
	{
		position = 0;
		name = 0;
		description = 0;
	}
};

class CueList : public <a href="#Metadata Data Class">Gap::Metadata::Data</a>, public <a href="#List Class">Gap::List</a>
{
protected:
	virtual void gdecl		Destroy( void );
public:
	virtual Data * gdecl 		Duplicate( void ) const = 0;
	virtual const Cue * gdecl	operator[]( int n ) const = 0;
	virtual bool gdecl		Add( const Cue &amp;c ) = 0;
	virtual bool gdecl		Add( const Cue &amp;c ) = 0;
	virtual bool gdecl 		Add( const char *name, const char *description,
						double position, int encoding ) = 0;
	virtual bool gdecl		Move( int n, double position ) = 0;
	virtual bool gdecl		Update( int n, const Cue &amp;c ) = 0;
	virtual bool gdecl		Remove( int n ) = 0;
};
</pre>

<p><b>Purpose</b><br>
A File Format plug-in uses this metadata data object to hold cue point information
when opening a file or to save cue point information when writing a file.
The plug-in must use the <code>aMetaCue</code>
<a href="#AudioFile::abilities"><code>ability</code></a> to
indicate to the host program that it supports cue points.

<p>The host program derives a class from this one to manage cue points.
A File Format plug-in developer must not derive a class from
this one.  Instead, it must use the <a href="#Metadata::Get"><code>Metadata::Get</code></a>
function on the <code>metadata</code> pointer passed in the
<a href="#AudioFile::Setup"><code>Setup</code></a> call (if set).

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th colspan="2" style="text-align:center;background-color:F0F0F0">Cue Structure</tr>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>position</code>
</td>
<td>
	The floating point time position of the cue point in seconds relative
	to the beginning of the file.  A cue point at the beginning of the
	file will have a position of 0.0.  A cue point at 2 minutes and
	half a second into the file will have a position of 120.5.
	<p>If the file stores cue points as a sample offset, then divide by the sampling
	rate to calculate the time.
</td>
</tr>

<tr>
<td valign=top>
	<code>name</code>
</td>
<td>
	A short string containing the name of the cue point.  This must not
	contain any control characters or new lines.
</td>
</tr>

<tr>
<td valign=top>
	<code>description</code>
</td>
<td>
	A string containing the description of the cue point.  This can
	contain many lines of formatted text.
</td>
</tr>

<tr>
<td valign=top>
	<code>Cue</code>
</td>
<td>
	Constructor to initialize all member variables.
</td>
</tr>
</table>

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th colspan="2" style="text-align:center;background-color:F0F0F0">CueList Class</tr>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	The host program owns the CueList object.  The plug-in must not delete
	or destroy it.
</td>
</tr>

<tr>
<td valign=top>
	<code>Duplicate</code>
</td>
<td>
	Makes a copy of all the cue point data and returns a new object holding that data.
	Plug-ins should not use this member.
</td>
</tr>

<tr>
<td valign=top>
	<code>operator&nbsp;[]</code>
</td>
<td>
	Returns a pointer to a Cue structure for the given zero based subscript index.
	This pointer cannot be used to modify or update a cue point's
	information.
	Use the <code>Move</code> or <code>Update</code> functions instead.
</td>
</tr>

<tr>
<td valign=top>
	<code>Add</code>
</td>
<td>
	Adds a new cue point to the end of the list using either an initialized Cue structure containing
	unicode strings or separate char strings and an encoding value.  The encoding value must be
	either <code>Gmd::Ansi</code> or <code>Gmd::Utf8</code>.
</td>
</tr>

<tr>
<td valign=top>
	<code>Move</code>
</td>
<td>
	Changes the time position of the cue point with the given index in the list.
</td>
</tr>

<tr>
<td valign=top>
	<code>Update</code>
</td>
<td>
	Updates the cue point with the given index with the new cue point.
	It essentially replaces the cue point at the given index in the list.
</td>
</tr>

<tr>
<td valign=top>
	<code>Remove</code>
</td>
<td>
	Removes the cue point at the given zero based index in the list.
</td>
</tr>
</table>

<p><b>Example</b><br>
Adds a new cue at 1 minute and 35 seconds with
the name "First" and the description "Example of a cue point",
then adds a second cue point using Ansi strings, and finally retrieves a copy
of the second cue point (at index 1).

<pre>
if ( metadata )
{
	Gmd::CueList	*cue = (Gmd::CueList *)Data-&gt;Get( Gmd::GWCueList );

	// Make sure host program assigned a CueList data object
	if ( cue )
	{
		Gmd::Cue	cuepoint;

		cuepoint.position = 95.0;
		cuepoint.name = L"First";
		cuepoint.description = L"Example of a cue point";
		// Add the first cue point
		cue-&gt;Add( cuepoint );

		// Add the second cue point
		cue-&gt;Add( "Second", 0, 123.4, Gmd::Ansi );

		// Get a copy of the second cue point
		if ( cue-&gt;Count() &gt; 1 )
			cuepoint = *(*cue)[1];
	}
}
</pre>
</div>


<h3><a name="Metadata PictureList Class">PictureList Class</a></h3>
<p>The PictureList data class holds a list of pictures related to the audio file, such as
CD cover art, band or artist photo, etc.  Both the <code>Picture</code> and
<code>PictureList</code> classes reside in the <code>Gmd</code> namespace in <code>gwmetadata.h</code>.

<div class="in">
<p><b>Declaration</b><br>
<pre>
struct Picture
{
	enum Type
	{
		tOther, tIcon32x32, tIconOther, tCoverFront, tCoverBack, tLeaflet,
		tMedia, tLeadArtist, tArtist, tConductor, tBand, tComposer, tLyricist,
		tLocation, tDuringRecording, tDuringPerformance, tVideo, tReserved,
		tIllustration, tLogoBand, tLogoPublisher
	};
	const wchar_t	*format,
			*description;
	int		type,
			size;
	void		*picture;
	Picture( void )
	{
		format = description = 0;
		type = tOther;
		size = 0;
		picture = 0;
	}
};


class PictureList : public <a href="#Metadata Data Class">Gap::Metadata::Data</a>, public <a href="#List Class">Gap::List</a>
{
protected:
	virtual void gdecl		Destroy( void );
public:
	virtual const Picture * gdecl	operator[]( int n ) const = 0;
	virtual bool gdecl		Add( const Picture &amp;c ) = 0;
	virtual bool gdecl		Remove( int n ) = 0;
};
</pre>

<p><b>Purpose</b><br>
A File Format plug-in uses this metadata data object to hold pictures
when opening a file or to retrieve and save pictures when writing a file.
The plug-in must use the <code>aMetaPicture</code>
<a href="#AudioFile::abilities"><code>ability</code></a> to
indicate to the host program that it supports pictures.

<p>
A File Format plug-in developer should use the <a href="#Metadata::Get"><code>Metadata::Get</code></a>
function on the <code>metadata</code> pointer passed in the
<a href="#AudioFile::Setup"><code>Setup</code></a> call (if set) to retrieve the list.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th colspan="2" style="text-align:center;background-color:F0F0F0">Picture Structure</tr>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>format</code>
</td>
<td>
	The format of the image given as a <a href="http://www.ietf.org/rfc/rfc2045.txt">MIME</a>
	type and subtype string, such as "image/jpeg" or "image/png".
</td>
</tr>

<tr>
<td valign=top>
	<code>description</code>
</td>
<td>
	A short string containing a description of the photo (optional).
</td>
</tr>

<tr>
<td valign=top>
	<code>type</code>
</td>
<td>
	The type of picture as one of the <code>Type</code> enumerations.  See <a href="http://id3.org/id3v2.3.0#sec4.15">ID3 APIC Frame</a>.
</td>
</tr>

<tr>
<td valign=top>
	<code>size</code>
</td>
<td>
	The number of bytes of raw, binary picture data.
</td>
</tr>

<tr>
<td valign=top>
	<code>picture</code>
</td>
<td>
	The raw, binary picture data.  The data can be any kind of picture, such as
	JPEG, PNG, ICO, etc.  Plug-in developers are strongly encouraged to use
	either JPEG or PNG.
</td>
</tr>

</table>

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th colspan="2" style="text-align:center;background-color:F0F0F0">PictureList Class</tr>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	Destroys the picture list and frees all memory for storing the pictures.
</td>
</tr>

<tr>
<td valign=top>
	<code>operator&nbsp;[]</code>
</td>
<td>
	Returns a pointer to a Picture structure for the given zero based subscript index.
	This pointer cannot be used to modify or update a pictures.
	Use the <code>Remove</code> and <code>Add</code> functions to update a picture.
</td>
</tr>

<tr>
<td valign=top>
	<code>Add</code>
</td>
<td>
	Adds a new picture to the end of the list given a fully initialized Picture structure.
</td>
</tr>

<tr>
<td valign=top>
	<code>Remove</code>
</td>
<td>
	Removes the picture at the given zero based index in the list.
</td>
</tr>
</table>

<p><b>Example</b><br>
Writes the raw binary picture data of the first picture in the list to a previously opened file.

<pre>
if ( metadata )
{
	Gmd::PictureList *list = (Gmd::PictureList *)Data-&gt;Get( Gmd::GWPictureList );

	// Make sure host program assigned a PictureList data object
	if ( list && list-&gt;Count() &gt; 0 )
	{
		const Gmd::Picture	*picture = list[0];
		fwrite( picture-&gt;picture, 1, picture-&gt;size, file );
	}
}
</pre>
</div>

<h3><a name="Metadata Raw Class">Raw Class</a></h3>
<p>Raw or custom metadata class.  This class resides in the <code>Gmd</code>
namespace in <code>gwmetadata.h</code>.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class Raw : public <a href="#Metadata Data Class">Gap::Metadata::Data</a>
{
public:
	virtual Data * gdecl Duplicate( void ) const = 0;
        virtual int gdecl Size( void ) const = 0;
	virtual void * gdecl Data( void ) = 0;
};
</pre>

<p><b>Purpose</b><br>
The Raw class holds any kind of data.  The host program does not use Raw metadata objects, but passes
them between File Format objects so that custom metadata can be preserved across different files and file
types.  Only the plug-in knows how to correctly handle the data.

<p> <span style="color:#C00000;font-weight:bold">Important: A plug-in must provide a unique name
for the raw metadata so that it will not clash with other plug-ins.</span>  If one plug-in used a simple name
such as "RawArt" and a second plug-in used the same name but stored the image data in a different form,
that will cause errors between plug-ins.  Using the plug-in module's name may avoid such clashes, such as
"FLACFileRawArt".  Also note that if more than one Raw object has to be stored in the metadata container, then
each one must have a unique name.  Numbering can be used, such as "FLACFileRawArt01", "FLACFileRawArt02", etc.

<p>This object may be created by specifying the <code>Gmd::GWRaw</code> name in
<a href="#Metadata::New"><code>Metadata::New</code></a> function with a valid size.  Note that attempting to use
<a href="#Metadata::Get"><code>Metadata::Get</code></a> with <code>create</code> set to true will
fail because raw data with the name <code>Gmd::GWRaw</code> is not permitted in metadata.

<p>Plug-in developers are encouraged to derive a class from <a href="#Metadata Data Class">Metadata::Data</a>
instead of using Raw data.  <p>Check <code>gwmetadata.h</code> for standard data classes already defined for
any metadata your plug-in handles.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>


<tr>
<td valign=top>
	<code>Duplicate</code>
</td>
<td>
	Creates an exact, deep copy of the object.  The copy must not depend on the original data in
	any way.  The copy or the original may be destroyed at any time, so they must exist
	independently.
</td>
</tr>

<tr>
<td valign=top>
	<code>Size</code>
</td>
<td>
	Returns the size in bytes of the data.
</td>
</tr>

<tr>
<td valign=top>
	<code>Data</code>
</td>
<td>
	Returns a pointer to the data.
</td>
</tr>

</table>


</div>
</div>

<h2><a name="Asker Class">Asker Class</a></h2>
<p>The Asker Class provide a mechanism for a File Format plug-in
to ask the user for help if it encounters something wrong when
reading a file, such as a corrupt header or invalid file size
data.

<div class="in">
<p><b>Declaration</b><br>
<pre>
class Asker
{
protected:
	virtual ~Asker( void );
public:
	enum { No = 1, Yes = 2, Ok = 4, Cancel = 8, Abort = 16, YesNo = Yes|No };
	virtual int gdecl Ask( const wchar_t *message, int options, int def ) const;
	virtual void gdecl Destroy( void );
};
</pre>

<p><b>Purpose</b><br>
When a File Format plug-in opens a file for reading, it may encounter
invalid information, such as a bad file size, a truncated file,
or corrupt data.  The Asker Class allows the plug-in to ask the
user a question on how to handle the situation, or just provide
some information about the file.
<p>The host program creates a derived class from this one and assigns
it to the plug-in by calling its
<a href="#AudioFile::Setup"><code>Setup</code></a> function.
The plug-in normally just uses its own
<a href="#AudioFile::Ask"><code>Ask</code></a> function to
ask a question.  The plug-in must provide a message, one or more options
by ORing together the values given in the enumeration, and
a default answer (just one of the enumeration values) for situations
where the host program is unable to ask the user.

<p>This object and the <a href="#AudioFile::Ask"><code>Ask</code></a> function
may be used only within the
<a href="#AudioFile::Open"><code>Open</code></a> function.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>Asker</code>
</td>
<td>
	Protected destructor to make sure it is deleted from correct
	memory address space.
</td>
</tr>

<tr>
<td valign=top>
	<code>Ask</code>
</td>
<td>
	Prompts the user with the given message and specify one or
	more possible respones.  The default value must be set
	to the most appropriate response.  In some cases, the host
	program may use the default response directly instead of
	prompting the user.
</td>
</tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	The host program owns the Asker object.  The plug-in must not delete
	or destroy it.
</td>
</tr>
</table>

<p><b>Example</b><br>
Code fragment to ask the user how to handle a bad RIFF file
size in an <a href="#AudioFile::Open">AudioFile::Open</a> function.

<pre>
// filesize is the length of the file in bytes
// chunksize is the size of the main RIFF chunk size for a Wave file

if ( chunksize &gt; filesize - 8 )
{
	if ( Ask( L"RIFF file size is wrong.  Continue anyway?",
			Asker::YesNo, Asker::Yes ) == Asker::No )
		return Gerr::eAbort;

	// Fix size and continue (default behaviour)
	chunksize = filesize - 8;
}
</pre>
</div>

<h2><a name="File Format Reading">Reading</a></h2>
<p>File Format plug-ins that implement the reading portion of the
interface must use the <code>aRead</code>
<a href="#AudioFile::abilities"><code>ability</code></a>
and override the <a href="#AudioFile::Open">Open</a>,
<a href="#AudioFile::Read">Read</a>,
<a href="#AudioFile::Seek">Seek</a>,
<a href="#AudioFile::Close">Close</a>,
<a href="#AudioFile::Length">Length</a>, and
<a href="#AudioFile::GetFormat">GetFormat</a> functions.

<div class="in">
<h3><a name="AudioFile::Open">Open</a></h3>
<p>The <code>Open</code> function is the first step in reading
an audio file.

<div class="in">
<p><b>Declaration</b><br>
<code>Gerr::Error gdecl Open( const wchar_t *name, const Format *format = 0 );</code>

<p><b>Purpose</b><br>
This function opens the named file, determines the file's length in
samples, extracts format and encoding information, and prepares
the file for reading and decoding.  It must also read all cue points
and file information if the file stores such information and the
<code>cue</code> and <code>info</code> members are not null.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Parameter</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>name</code>
</td>
<td>
	Specifies the name of the file.  This is the full pathname of
	the file.  In future versions of the SDK, it could specify a URL.
</td>
</tr>

<tr>
<td valign=top>
	<code>Format</code>
</td>
<td>
	An optional pointer to a <a href="#Format Class">Format</a> object.
	If the file is headerless
	or does not contain any structure information, the host program
	may provide a format specified by the user.  The plug-in must use
	the format to decode the audio, if appropriate.  The host program
	provides a <a href="#Format Class">Format</a> object only if
	the plug-in uses the <code>aRaw</code>
	<a href="#AudioFile::abilities"><code>ability</code></a> and
	no other plug-ins were able to open the file.

	<p>The host program may destroy the Format object immediately
	after calling <code>Open</code>, so this function must make
	a copy of the format information internally, if required.
</td>
</tr>

</table>

<p>If the plug-in cannot find or open the file, then it must
return the <a href="#Error Codes"><code>Gerr::eOpen</code></a>
error code.

<p>If a file is already opened, it is recommended that the
file be closed and the new file opened.  However,
the <a href="#Error Codes"><code>Gerr::eForbidden</code></a>
error code may be returned instead.

<p>If the plug-in does not recognize the file's type and it
cannot handle raw/headerless audio, then it must
return the <a href="#Error Codes"><code>Gerr::eType</code></a>
error code.

<p>If the plug-in recognizes the type, but is not able to decode
the audio, then it must
return the <a href="#Error Codes"><code>Gerr::eFormat</code></a>
error code.  If the plug-in handles raw/headerless files and
a <a href="#Format Class">Format</a> object is provided and the
file appears to be raw/headerless, then the <a href="#Format Class">Format</a>
object should be used to interpret and decode the data.  If the
<a href="#Format Class">Format</a> object does not belong to the plug-in,
it must return the <a href="#Error Codes"><code>Gerr::eFormat</code></a>
error code.

<p>If the plug-in encounters ambiguous or corrupt information, it
may use the <a href="#Asker Class">Asker</a> function
to ask the user how to proceed.  If the user does not want to
proceed, then the plug-in
must return the <a href="#Error Codes"><code>Gerr::eAbort</code></a>
error code.

<p>If the plug-in encounters corrupt or invalid data, such
as a negative sampling rate or less than one channel, then it
must return the <a href="#Error Codes"><code>Gerr::eCorrupt</code></a>
error code.

<p>If the file contains multiple concatenated streams of audio
that have different
sampling rates or a different number of channels, then the plug-in
must return the <a href="#Error Codes"><code>Gerr::eClash</code></a>
error code.

<p>If the exact number of decoded samples cannot be determined,
it must set the <code>fUnsized</code>
<a href="#Format::Flags"><code>flag</code></a> in the
<a href="#Format Class">Format</a> object that is returned by
the <a href="#AudioFile::GetFormat"><code>GetFormat</code></a>
function.

<p>If the file contains no audio, then the plug-in
must return the <a href="#Error Codes"><code>Gerr::eEmpty</code></a>
error code.

<p>If the format does not allow consistent, sample accurate seeking,
then it must set the <code>fSequential</code>
<a href="#Format::Flags"><code>flag</code></a> in the
<a href="#Format Class">Format</a> object that is returned by
the <a href="#AudioFile::GetFormat"><code>GetFormat</code></a>
function.

<p>Other error codes may be returned, as appropriate.

<p><b>Important:</b> If the <code>Open</code> function fails for any reason,
it must set the reading functionality of the plug-in back to
its original state so that it can be used to open other files.  It
must close the input file if it was opened.  The
<a href="#AudioFile::GetFormat"><code>GetFormat</code></a> function
must return the default or custom format in this case.

<p>The <code>Open</code> function must read cue point and file
information, if supported.

<p>Immediately after a successful <code>Open</code> call, a
<a href="#AudioFile::GetFormat"><code>GetFormat</code></a>
call must return a pointer to a <a href="#Format Class">Format</a>
object that exactly describes the format of the opened file.
The host program must be able to use this object in the
<a href="#AudioFile::Begin"><code>Begin</code></a> function to
create a file with the same encoding, sampling rate, channels,
and bitrate.

<p>After a successful <code>Open</code> call, the first
<a href="#AudioFile::Read"><code>Read</code></a> call must
return the requested number of decoded samples from the beginning
of the file.  Any cue points and file information must be stored
using the <code>cue</code> and <code>info</code> members, if assigned.

</div>

<h3><a name="AudioFile::Read">Read</a></h3>
<p>The <code>Read</code> function is the next step in reading audio data.

<div class="in">
<p><b>Declaration</b><br>
<code>int gdecl Read( audio *buffer, int samples );</code>

<p><b>Purpose</b><br>
This function reads and decodes/converts audio data and
fills the buffer with the requested number of
<a href="#audio Type"><code>audio</code></a> <a href="#Sample">samples</a>

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Parameter</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>buffer</code>
</td>
<td>
	Points to a buffer large enough to hold the requested number of
	<code>audio</code> <a href="#Sample">samples</a>.  The buffer
	must not be used to temporarily store larger amounts of data.
</td>
<tr>
<td valign=top>
	<code>samples</code>
</td>
<td>
	Specifies the number of samples to store in the buffer.  If the value is 1000,
	then 1000 <code>audio</code> values must be stored for a mono file.
	2000 values must be stored for a stereo file.  Less samples may be stored
	only at the end of the file when the requested number of samples is
	not available.  Otherwise no less than the requested number of samples
	may be stored.
</td>
</tr>
</table>

<p>If a file has not been opened yet, this function must return
the -<a href="#Error Codes"><code>Gerr::eForbidden</code></a> negative
error code.

<p>The function <b>must</b> provide the requested number of samples,
until the end of the file is reached.
The return value must be the actual number of <a href="#Sample">samples</a>
in the buffer, or 0 if no more data is available, or a negative error
code, such as -<a href="#Error Codes"><code>Gerr::eRead</code></a> if
an error occurred.

<p>Other error codes may be returned, as appropriate.

<p>The <code>Read</code> function must update its file pointer so
that the next block of audio is read from the file during the next call.

</div>


<h3><a name="AudioFile::Seek">Seek</a></h3>
<p>Support for random access through the <code>Seek</code> function is
required.  The <code>fSequential</code>
<a href="#Format::Flags"><code>flag</code></a> must be set in the
<a href="#Format Class">Format</a> object returned by
the <a href="#AudioFile::GetFormat"><code>GetFormat</code></a>
function if sample accurate seeking is not supported.

<div class="in">
<p><b>Declaration</b><br>
<code>Gerr::Error gdecl Seek( int64 start );</code>

<p><b>Purpose</b><br>
This function seeks to an exact decoded sample position within
the file so that the next <a href="#AudioFile::Read">Read</a>
call will read decoded audio from that position.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Parameter</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>start</code>
</td>
<td>
	Specifies the exact sample seek position from the beginning
	of the file.  It is the number of decoded samples.
</td>
</tr>
</table>

<p>This function must be accurate to the exact sample.  If seeking
cannot be that accurate for the opened file, then
the <code>fSequential</code>
<a href="#Format::Flags"><code>flag</code></a> must be set
when the file is opened.  Seeking must be as close as possible
to the sample position.

<p>The <code>fSequential</code> flag must be set for any
encoding algorithm that depends on previously decoded audio,
such as delta encoded audio.  Otherwise seeking to a position and
reading audio <b>must</b> give the exact same values that
sequentially reading from the beginning of the file would give.
Any internal decoder/converter state data must be adjusted
as required so that the next <a href="#AudioFile::Read">Read</a>
call produces the correct data.

<p>If a file has not been opened yet, this function must return
the <a href="#Error Codes"><code>Gerr::eForbidden</code></a>
error code.  If seeking fails, the function may return
the <a href="#Error Codes"><code>Gerr::eSeek</code></a> error code.

</div>


<h3><a name="AudioFile::Close">Close</a></h3>
<p>This is the final step in the reading interface.

<div class="in">
<p><b>Declaration</b><br>
<code>Gerr::Error gdecl Close( void );</code>

<p><b>Purpose</b><br>
This function closes the file and frees any allocated memory, returning
the plug-in to its original state before the file was opened.

<p>The <a href="#AudioFile::GetFormat"><code>GetFormat</code></a>
function must return a default (or custom) format rather than the format
of the previously opened file.

<p>If a file is not been opened, this function must return
the <a href="#Error Codes"><code>Gerr::eForbidden</code></a>
error code.

<p>Other error codes may be returned, as appropriate.

<p>The host program may call <a href="#AudioFile::Open">Open</a> immediately
after closing the file to start reading a different file.

</div>

</div>

<h2><a name="File Format Writing">Writing</a></h2>
<p>File Format plug-ins that implement the writing portion of the
interface must use the <code>aWrite</code>
<a href="#AudioFile::abilities"><code>ability</code></a>
and override the <a href="#AudioFile::Begin">Begin</a>,
<a href="#AudioFile::Write">Write</a>,
<a href="#AudioFile::End">End</a>,
<a href="#AudioFile::GetFormat">GetFormat</a>, and
<a href="#AudioFile::Formats">Formats</a> functions.

<div class="in">
<h3><a name="AudioFile::Begin">Begin</a></h3>
<p>This is the first step in writing a file.

<div class="in">
<p><b>Declaration</b><br>
<code>Gerr::Error gdecl Begin( const wchar_t *name, const Format &amp;format );</code>

<p><b>Purpose</b><br>
This function creates a new file with the given name and
<a href="#Format Class">format</a>.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Parameter</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>name</code>
</td>
<td>
	Specifies the full pathname of the file to create.  If the
	file exists, it must be overwritten and truncated.  The host program is
	responsible for ensuring that it is safe to overwrite a file.
</td>
</tr>

<tr>
<td valign=top>
	<code>format</code>
</td>
<td>
Specifies the <a href="#Format Class">format</a> to use when
encoding the audio.  This is a reference to a <a href="#Format Class">Format</a>
object created by the plug-in itself, either by the
<a href="#AudioFile::Formats">Formats</a> function or the
<a href="#AudioFile::GetFormat">GetFormat</a> function.
The host program must not
pass in a <a href="#Format Class">Format</a> object created by
a separate plug-in (certainly not one created by a different
module).

<p>The host program may destroy the Format object immediately
after calling <code>Begin</code>, so this function must make
a copy of the format information internally, if required.
</td>
</tr>

</table>

<p>If the file cannot be created because a read-only file with the
same name already exists, then this function must return
the <a href="#Error Codes"><code>Gerr::eReadOnly</code></a>
error code.  Otherwise if the file cannot be created, then
the <a href="#Error Codes"><code>Gerr::eCreate</code></a> error
code should be returned.

<p>If the <a href="#Format Class">Format</a> object was not
created by (or does not belong to) the plug-in, then the
<a href="#Error Codes"><code>Gerr::eFormat</code></a>
error code must be returned.

<p>This function must create the file and setup any encoders required
to convert the audio data.

<p>The function may write <a href="#Metadata Class">metadata</a>, if assigned.
However it is strongly recommended to write that in the
<a href="#AudioFile::End">End</a> function when possible
since information and
cue points may be added during writing and processing.  The metadata
may not be complete until <a href="#AudioFile::End">End</a> is
called.

<p>If a file was created previously and the
<a href="#AudioFile::End">End</a>
function has not been called, then
<a href="#Error Codes"><code>Gerr::eForbidden</code></a>
error code must be returned to tell the host program it
has not finished writing the previous file.

<p><b>Important:</b> If the <code>Begin</code> function fails for any reason,
it must set the writing functionality of the plug-in back to its original state
so that it can be used to write another file.  Any opened output file must be closed.

<p>Other error codes may be returned, as appropriate.

<p>After a successful <code>Begin</code> call, the plug-in must be prepared to
accept audio through the <a href="#AudioFile::Write"><code>Write</code></a> function.
</div>

<h3><a name="AudioFile::Write">Write</a></h3>
<p>This is the next step in writing a file.

<div class="in">
<p><b>Declaration</b><br>
<code>Gerr::Error gdecl Write( const audio *buffer, int samples );</code>

<p><b>Purpose</b><br>
This function encodes/converts audio data in the buffer and
writes it to the file.  The function must accept all of the
<a href="#audio Type"><code>audio</code></a> <a href="#Sample">samples</a>
in the buffer.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Parameter</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>buffer</code>
</td>
<td>
	Buffer containing the <a href="#audio Type"><code>audio</code></a>
	<a href="#Sample">samples</a> to be written to the file.  These
	must be encoded or converted to the format specified in the
	<a href="#AudioFile::Begin">AudioFile::Begin</a> function when
	the file was created.
</td>
</tr>

<tr>
<td valign=top>
	<code>samples</code>
</td>
<td>
Specifies the number of samples in the buffer.  For a mono file,
it specifies the number of <a href="#audio Type"><code>audio</code></a>
values in the buffer.  For a stereo file, it specifies the number
of <a href="#audio Type"><code>audio</code></a> pair values in
the buffer.
</td>
</tr>
</table>

<p>If the amount of audio provided is not enough for the encoding
algorithm, then it must be buffered internally until enough data
is received.

<p>If writing to the file fails, then the
<a href="#Error Codes"><code>Gerr::eWrite</code></a> error
code should be returned.

<p>Other error codes may be returned, as appropriate.

</div>

<h3><a name="AudioFile::End">End</a></h3>
<p>This is the last step in writing a file.

<div class="in">
<p><b>Declaration</b><br>
<code>Gerr::Error gdecl End( void );</code>

<p><b>Purpose</b><br>
This function writes any internally buffered audio data to
the file and closes the file.  This may involve updating
file header and structure information, writing
<a href="#Metadata Class">metadata</a>
(if assigned and not already written in the
<a href="#AudioFile::Begin">Begin</a>
function), closing the file itself, and freeing any allocated
memory.

<p>It is strongly recommended to write
<a href="#Metadata Class">metadata</a>
during this function rather than during
<a href="#AudioFile::Begin">Begin</a>
since information and
cue points may be added during writing and processing.  The metadata
may not be complete until <a href="#AudioFile::End">End</a> is
called.

<p>Before returning, whether successfully or with an error, the
plug-in must be in its original state and prepared to created and
write new files.  The output file must be closed.

<p>If a file has not been created yet, then the
<a href="#Error Codes"><code>Gerr::eForbidden</code></a> error
code must be returned.

<p>If the final audio or structure information could not be written,
then the <a href="#Error Codes"><code>Gerr::eWrite</code></a> error
code must be returned.

<p>Other error codes may be returned, as appropriate.

</div>
</div>

<h2><a name="File Format Management">Format Management</a></h2>
<p>A single file type may contain many different audio formats
and encodings.  The RIFF Wave type, for example, may contain
audio encoded as PCM, ADPCM, MPEG, and many more, with
different sampling rates, different numbers of channels, and
different compression ratios.

<p>The <a href="#Format Class">Format Class</a> encapsulates details
of the all formats for a single file type so that the host program
does not require specific knowledge about the format.  The
<a href="#Format Class">Format Class</a> also provides a way for
the host program to modify the sampling rate, channels, and bitrate
when creating a file.

<p>For each file type a plug-in module supports, it must derive
its own <a href="#Format Class">Format Class</a> to store
information specific to formats supported by the file type.  For example,
if a File Format plug-in module supports RIFF Wave files and Apple
AIFF files, then it would need two separate derived
<a href="#Format Class">Format</a> classes, such as
<code>WaveFormat</code> and <code>AppleFormat</code>.

<p>To supports custom formats, the plug-in must implement a
<a href="#Page">Page</a> interface and have the <code>aPage</code>
<a href="#AudioFile::abilities"><code>ability</code></a> set.

<h3><a name="AudioFile::GetFormat">GetFormat</a></h3>
<p>The <code>GetFormat</code> function returns a
certain <a href="#Format Class">Format</a>
object, depending on the state of the plug-in.

<div class="in">
<p><b>Declaration</b><br>
<code>Format * gdecl GetFormat( void );</code>

<p><b>Purpose</b><br>
This function returns a pointer to a <a href="#Format Class">Format</a> object.
The information contained in the format object depends on the state
of the plug-in.  There are three states: the default state,
the custom state, and the reading state.

<div class="in">
<p><b>Default State</b><br>
When the plug-in is created, or when a file is not currently opened
for reading, the default format information must be returned.  This
is the best format to use when creating a new file.  The host program
may use this format in a call to the <a href="#AudioFile::Begin">Begin</a>
function.

<p><b>Custom State</b><br>
If the plug-in supports custom formats by implementing a
<a href="#Page">Page</a> interface and the host program
successfully used it, the format information
returned must match the custom format settings selected by the user.
This becomes the new default format until the plug-in is destroyed.
The host program will use the format in the
<a href="#AudioFile::Begin">Begin</a> function to create a file
using the user's settings.

<p><b>Reading State</b><br>
If a file is successfully opened, then the format information
must exactly match the file's format.  The host program will
use this to display the information to the user and may
use the format in the <a href="#AudioFile::Begin">Begin</a>
function when saving the modified file.
</div>

<p>The host program owns the return format object and will destroy
it when it is no longer needed.  A plug-in must never return
a format object that modifies global variables since the host
program may change the format's sampling rate, channels, or bitrate.
It must return a copy of the format or use the
<a href="#Format::Duplicate"><code>Format::Duplicate</code></a>
function.

</div>

<h3><a name="AudioFile::Formats">Formats</a></h3>
<p>The <code>Formats</code> function provides the host program
with a list of formats the plug-in supports.  This is used
to create a file in a certain format.

<div class="in">
<p><b>Declaration</b><br>
<code>FormatList * gdecl Formats( void );</code>

<p><b>Purpose</b><br>
This function returns a <a href="#FormatList Class">FormatList</a>
object listing formats that the plug-in supports.
It is recommended that only the most popular or most appropriate
formats be included in the list to reduce the length of the
list presented to the user.

<p>The host program owns the list object and will destroy it when
it is no longer needed.  The <a href="#Format Class">Format</a> objects
returned by the list's
<a href="#FormatList::index"><code>index operator</code></a> must
not be contain global data that would be modified by the
host problem when it modifies the sampling rate, channels,
or bitrate.

</div>

<h2><a name="Audio Host Program Usage">Host Program Usage</a></h2>

<p>This section describes how a host program uses File
Format classes.  The host program first loads the File Format module then calls the
<a href="#Interface Function">Interface Function</a> to get a pointer to
the <a href="#Interface Structure">Interface Structure</a>.

<div class="in">

<h3><a name="Audio Host Reading">Reading</a></h3>
<p>The host program performs the following steps to open
and read a file:

<ol>

<li>It calls the <a href="#Interface::create"><code>Interface::create</code></a>
function passing in the file's full pathname to create an AudioFile object
that can open/read/decode the file.  If none of the plug-ins in the module
can handle the file, 0 must be returned by the create function.  The
host program will try the next module (if any other modules are available).
If no compatible plug-in is found, the host program may attempt to
open the file as raw/headerless audio.  In that case, it will call
the <a href="#Interface::create"><code>Interface::create</code></a> function
with the <a href="#AudioFile::name"><code>type name</code></a> of the
of plug-in to create.

<li>Once an appropriate plug-in is created, it may call the
<a href="#AudioFile::Setup">Setup</a> function to provide derived
<a href="#Metadata Class">Metadata</a> and
<a href="#Asker Class">Asker</a> objects.  However, it may not call this
function or it may pass null pointers.

<li>It may use the <a href="#PluginObject::GetFormat">GetPage</a>
function to allow the user to choose a custom format
for a raw/headerless file, if the <code>aPage</code>
<a href="#AudioFile::abilities"><code>ability</code></a> is
set.

<li>It calls
the <a href="#AudioFile::Open">Open</a> function providing the
same full pathname of the file.  A <a href="#Format Class">Format</a> object
may be provided when opening a raw/headerless file, but in
most cases this parameter will be 0.

<li>It may destroy the <a href="#Format Class">Format</a> object, if one
was provided during the <a href="#AudioFile::Open">Open</a> call.

<li>It may use the <a href="#AudioFile::GetFormat">GetFormat</a>
function at any time to obtain format information for the file,
such as its sampling rate, number of channels, and bitrate.

<li>It may examine cue points and file information stored through
the <code>cue</code> and <code>info</code> members.

<li>It may <a href="#AudioFile::Read">Read</a> or
<a href="#AudioFile::Seek">Seek</a> within the file any number of
times.

<li>It closes the file with a call to
<a href="#AudioFile::Close">Close</a> when it no longer needs
the file.

<li>It may reuse the plug-in object to open another file of the
same type.

<li>It destroys the plug-in object when it is no longer needed.
</ol>

The host program may open several files of the same type at the
same time.  Plug-ins must not use any global data that would
be modified by multiple instances of the same plug-in.

<h3><a name="Audio Host Writing">Writing</a></h3>
<p>The host program performs the following steps to create
and write a file:

<ol>

<li>It calls the <a href="#Interface::create"><code>Interface::create</code></a>
function passing in the <a href="#AudioFile::name"><code>type name</code></a>
of the plug-in to create.

<li>It calls the
<a href="#AudioFile::Setup">Setup</a> function to provide derived
<a href="#Metadata Class">Metadata</a> and
<a href="#Asker Class">Asker</a> objects.  Any of these may
be 0.  The <a href="#Asker Class">Asker</a> object most likely
will be 0 since it must not be used for writing.

<li>It may use the <a href="#PluginObject::GetFormat">GetPage</a>
function to allow the user to set a custom format, if the
<code>aPage</code>
<a href="#AudioFile::abilities"><code>ability</code></a> is
set.

<li>It calls either <a href="#AudioFile::GetFormat">GetFormat</a>
to get a default/custom format or <a href="#AudioFile::Formats">Formats</a>
to get a list of formats and allows the user to select one.

<li>It calls <a href="#AudioFile::Begin">Begin</a> specifying
the full pathname of the file and a format object.

<li>It may delete the <a href="#Format Class">Format</a>
object or the <a href="#FormatList Class">FormatList</a> object at any time.

<li>It writes the audio data with one or more calls to
<a href="#AudioFile::Write">Write</a>.

<li>It ends writing with a call to <a href="#AudioFile::End">End</a>.

<li>It may reuse the plug-in to write another file.

<li>It destroys the plug-in when it is no longer needed.

</ol>

<h3><a name="Audio Host Format">Format Usage</a></h3>
<p>The host program uses <a href="#Format Class">Format</a> objects
in the following ways:
<ul>
<li>It obtains a <a href="#Format Class">Format</a> object from
a call to <a href="#AudioFile::GetFormat">GetFormat</a>.  Or
it calls <a href="#AudioFile::Formats">Formats</a> to obtain
a <a href="#FormatList Class">FormatList</a> object, then uses the
<a href="#FormatList::index"><code>index operator</code></a>.

<li>It may call <code>SetRate</code>, <code>SetChannels</code>,
or <code>SetBitrate</code> at any time.  Note that it may
change any <a href="#Format Class">Format</a> object, even
those contained in a <a href="#FormatList Class">FormatList</a>.

<li>It may call <code>Type</code>, <code>Description</code>,
<code>Extension</code>, <code>Rate</code>, <code>Channels</code>
or <code>Bitrate</code> at any time.

<li>If the <a href="#Format Class">Format</a> object was obtained
through <a href="#AudioFile::GetFormat">GetFormat</a>, it
destroys the object.

<li>If the <a href="#Format Class">Format</a> object was obtained
through a <a href="#AudioFile::Formats">Formats</a> list object
item, then it destroys the <a href="#FormatList Class">FormatList</a>
object only.  It <b>does not</b> destroy individual format objects
contained in the list.  The list itself owns those and must destroy them
when the list is destroyed.
</ul>

</div>


<h1><a name="Visual Plug-ins">Visual Plug-ins</a></h1>
<p>Visual plug-ins display audio data or status information in
real-time.  A host program may display many visuals at the same
time.  GoldWave, for example, displays 4 visuals, which the
user can change and configure.

<p>The most important member of a visual plug-in is the
<a href="#Visual::Draw"><code>Draw</code></a> function.
It is the only function that must be implemented.

<p>Developers can use the Windows GDI, OpenGL, or directly access
the display buffer.  Note that DirectX is not supported since it
lacks the ability to use and create multiple instances within a single
program.

<p>All drawing is done in an offscreen buffer.  The
host program copies that buffer to the screen after calling
the visual's <a href="#Visual::Draw"><code>Draw</code></a> function.
The offscreen buffer uses a 16 bit RGB colour
<a href="#Pixel Structure">format</a>.

<p>The host program uses a separate thread when calling
the <a href="#Visual::Draw"><code>Draw</code></a> function, but
it must ensure it sequentially calls the visual's other member
functions, except in then case of a <a href="#Page">Page</a> interface.

Visuals that implement a <a href="#Page">Page</a> interface
must be designed to be thread safe.  A visual may be actively
updated and drawn on one thread while the
<a href="#Page">Page</a> user interface is shown and managed
on another thread.  When a user changes a visual's settings on the
page, the visual must make sure that it is not in the middle of
drawing by using a critical section.

<p>Visual related classes belong to the <code>Gvp</code> (<b>G</b>oldWave
<b>V</b>isual <b>P</b>lug-in) namespace.

<h2><a name="State Structure">State Structure</a></h2>
<p>

<div class="in">
<p><b>Declaration</b><br>
<pre>
struct State
{
	int			width,
				height,
				channels,
				side,
				samplingRate,
				playbackState,
				recordState,
				frameRate;
	const Gap::Metadata	*metadata;
};
</pre>

<p><b>Purpose</b><br>
This structure holds state information that a visual can use when
drawing.  The <code>width</code> and <code>height</code> are
the most important members.  They define the size in pixel of the
visual's offscreen buffer.

<p>The structure hold information that does not
change frequently from one instant to the next.  The host
program occasionally uses the
<a href="#Visual::SetState"><code>SetState</code></a>
function to change these.

<p>The host program uses the
<a href="#DrawInfo Structure">DrawInfo Structure</a>
and the
<a href="#Visual::Draw"><code>Draw</code></a> function
to provide information that changes quickly.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>width</code>
</td>
<td>
	Stores the current width in pixels of the video buffer for the
	visual.  See the
	<a href="#Pixel Structure">Pixel Structure</a> section
	for more information.
</td>
</tr>

<tr>
<td valign=top>
	<code>height</code>
</td>
<td>
	Stores the current height in pixels of the video buffer for the
	visual. See the
	<a href="#Pixel Structure">Pixel Structure</a> section
	for more information.
</td>
</tr>

<tr>
<td valign=top>
	<code>channels</code>
</td>
<td>
	Specifies the number of channels contained in the audio
	data passed to the visual.
</td>
</tr>

<tr>
<td valign=top>
	<code>side</code>
</td>
<td>
	Specifies the side where the visual is being displayed.  This can
	be one of three different values:

	<p><table align="center" border="0" width="100%" cellpadding=1>
	<tr><th align=left>Value</th><th align=left>Purpose</th></tr>

	<tr><td>sLeft</td><td>The visual is on the left side of the screen
	and should display left channel audio only.</td></tr>

	<tr><td>sRight</td><td>The visual is on the right side of the screen and
	should display right channel audio only.</td></tr>

	<tr><td>sBoth</td><td>The plug-in is neither left or right.  Both
	channels should be displayed.</td></tr>
	</table>

	<p>The host program provides this value to help tell the visual
	what channel to display.  The visual may ignore this value if
	it provides a way to allow the user to select what channel or channels
	it displays.
</td>
</tr>

<tr>
<td valign=top>
	<code>samplingRate</code>
</td>
<td>
	Specifies the sampling rate of the audio data passed to the visual.
</td>
</tr>

<tr>
<td valign=top>
	<code>playbackState</code>
</td>
<td>
	Specifies the current playback state.  It is one of the following
	values:
	<p><table align="center" border="0" width="100%" cellpadding=1>
	<tr><th align=left>Value</th><th align=left>Purpose</th></tr>
	<tr><td>pStop</td><td>Playback is stopped or inactive.</td></tr>
	<tr><td>pPause</td><td>Playback is paused.</td></tr>
	<tr><td>pPlay</td><td>Playback is active.</td></tr>
	<tr><td>pRewind</td><td>Audio is rewinding.</td></tr>
	<tr><td>pFast</td><td>Audio is fast forwarding.</td></tr>
	</table>

	<p>A visual would use this value to draw the current playback
	state.  For example, it could display the word "Playing" or a right
	pointing triangle for a <code>pPlay</code> value and the
	word "Stopped" or a square for a <code>pStop</code> value.
</td>
</tr>

<tr>
<td valign=top>
	<code>recordState</code>
</td>
<td>
	Specifies the current recording state.  It is one of the following
	values:
	<p><table align="center" border="0" width="100%" cellpadding=1>
	<tr><th align=left>Value</th><th align=left>Purpose</th></tr>
	<tr><td>rStop</td><td>Recording is stopped or inactive.</td></tr>
	<tr><td>rRecord</td><td>Recording is active.</td></tr>
	<tr><td>rPause</td><td>Recording is paused.</td></tr>
	</table>

	<p>A visual would use this value to draw the current recording
	state.  For example, it could display the word "Recording" or a red
	circle for a <code>rRecord</code> value and the
	word "Stopped" or a red square for a <code>rStop</code> value.
</td>
</tr>

<tr>
<td valign=top>
	<code>frameRate</code>
</td>
<td>
	Specifies the frame rate at which the host program is drawing the
	visual.  GoldWave uses 60fps by default, but it can range from
	10fps to 200fps depending on the user's settings.
</td>
</tr>

<tr>
<td valign=top>
	<code>metadata</code>
</td>
<td>
	A pointer to a <a href="#Metadata Class">Gap::Metadata</a>
	that holds information about the file, such as the artist, title,
	copyright, cue points, cover art, and more.  This class is part of the
	<a href="#File Format Plug-ins">File Format Plug-in</a>) interface.
	It may be NULL if no information is available, so check before using it.
</td>
</tr>

</table>
</div>


<h2><a name="Visual Class">Visual Class</a></h2>
<p>This is the main plug-in class for visuals.  There are three kinds
of visuals, as defined by the
<a href="#Visual::abilities"><code>abilities</code></a>.
A <i>Status</i> visual usually displays elapsed
time and playback or recording states.  It is a drawn in a window of
fixed size, 100 pixels wide by 20 pixels high.  A <i>Level</i>
visual displays audio amplitude levels in a window of variable
size.  A <i>Graph</i> visual displays the audio waveform or
frequency magnitudes graphically in a window of variable size.  The graph
may show the left channel, the right channel, or both.  The host
program provides information about what channel should be graphed
(see <code>State::side</code> above).

<div class="in">
<p><b>Declaration</b><br>
<pre>
class Visual : public Gbase::PluginObject, public State
{
protected:
	bool	refresh;
	virtual ~Visual();

public:
	Visual( void );
	virtual void gdecl Destroy( void );
	virtual bool gdecl Draw( DrawInfo &amp;info );
	virtual void gdecl SetState( const State &amp;set, unsigned int flags );
	virtual int  gdecl Event( EventInfo &amp;event );
};
</pre>

<p><b>Purpose</b><br>
This is the base class for all Visual plug-ins.  It is derived from
the <code>PluginObject</code> class and the <code>State</code> structure.
To create a visual,
derive a class from this one.  Refer to the
<a href="#PluginObject">PluginObject</a> and
<a href="#State Structure">State Structure</a>
sections for more information.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>refresh</code>
</td>
<td>
	This value is set to true whenever a
	<a href="#Visual::SetState"><code>Visual::SetState</code></a>
	call occurs.
	The <a href="#Visual::Draw"><code>Draw</code></a>
	function usually must redraw the entire
	video buffer (for example, the width and height state may have
	changed).  It must set the value to false before returning.

	<p>When this value is false, the
	<a href="#Visual::Draw"><code>Visual::Draw</code></a>
	function should draw only areas that need to be update with
	new audio data.  Constant graphics like axes and borders should
	not be redrawn unless <code>refresh</code> is true.
</td>
</tr>

<tr>
<td valign=top>
	<code>~Visual</code>
</td>
<td>
	Protected destructor prevents host program from accidentally deleting
	object from its own address space.
</td>
</tr>

<tr>
<td valign=top>
	<code>Visual</code>
</td>
<td>
	Constructor initializes all <a href="#State Structure">State</a>
	member variables to default values.
</td>
</tr>

<tr>
<td valign=top>
	<code>Destroy</code>
</td>
<td>
	This function is used by the host program to destroy the visual
	and delete it from the module's address space.  This
	function should not be overridden.  Perform any cleanup in
	the destructor instead.
</td>
</tr>

<tr>
<td valign=top>
	<code>Draw</code>
</td>
<td>
	Updates the video buffer.  See
	<a href="#Visual::Draw"><code>Draw</code></a> for more
	information.
</td>
</tr>

<tr>
<td valign=top>
	<code>SetState</code>
</td>
<td>
	Changes one or more of the <a href="#State Structure">State</a>
	values.  See
	<a href="#Visual::SetState"><code>SetState</code></a> for more
	information.
</td>
</tr>

<tr>
<td valign=top>
	<code>Event</code>
</td>
<td>
	Passes user interface events (such as mouse movement and buttons)
	to the visual.  See
	<a href="#Visual::Event"><code>Event</code></a> for more
	information.
</td>
</tr>

</table>

<p>Every derived visual must override the following functions:
<ul>
<li> <a href="#Visual::Draw"><code>Visual::Draw</code></a>
<li> <a href="#PluginObject::Ability"><code>PluginObject::Ability</code></a>
<li> <a href="#PluginObject::Name"><code>PluginObject::Name</code></a>
</ul>

<p>If a visual provides a user interface or has settings, it must override the
following functions:
<ul>
<li> <a href="#PluginObject::GetPage"><code>PluginObject::GetPage</code></a>
<li> <a href="#PluginObject::Get"><code>PluginObject::Get</code></a>
<li> <a href="#PluginObject::Set"><code>PluginObject::Set</code></a>
</ul>

<p>In some cases, it may need to override the
<a href="#Visual::SetState"><code>Visual::SetState</code></a>
function to detect when state variables are changed.

<p>If event processing is required, override the
<a href="#Visual::Event"><code>Visual::Event</code></a>
function and use the <code>aEvent</code>
<a href="#Visual::abilities"><code>ability</code></a>.

<p>Events are not fully implemented in GoldWave yet.</p>

</div>

<h2><a name="Pixel Structure">Pixel Structure</a></h2>
<p>All visuals use a 32-bit ARGB colour format as illustrated.

<p>
<center>
<img src="pixel.png" alt="Pixel Format"><br>
Figure: Pixel Format
</center>


<div class="in">
<p><b>Declaration</b><br>
<pre>
struct Pixel
{
	unsigned char	b, g, r, a;
	enum Mask { mRed = 0x00FF0000, mGreen = 0x0000FF00,
                    mBlue = 0x000000FF, mAlpha = 0xFF000000 };
	enum Full { fRed = 0xFF, fGreen = 0xFF, fBlue = 0xFF, fAlpha = 0xFF };
};
</pre>

<p><b>Purpose</b><br>
This structure describes the bit layout of the pixel format used
in the visual's video buffer.  Note that alpha values are currently ignored and must be 0.


<p><b>Example</b><br>
Draws a yellow pixel in the upper left corner of the video buffer.

<pre>
#include "gwvisual.h"
using namespace Gvp;

// ...

bool gdecl SetPixelVisual::Draw( DrawInfo &amp;info )
{
	// Make sure the video buffer is valid
	if ( width &lt;= 0 || height &lt;= 0 )
		return false;

	if ( refresh )	// Don't redraw the same pixel every time (be efficient)
	{
		info.pixel[0].r = Pixel::fRed;
		info.pixel[0].g = Pixel::fGreen;
		info.pixel[0].b = 0;

		// could do: *(unsigned *)(info.pixel) = Pixel::mRed | Pixel::mGreen;

		refresh = false;
		return true;
	}

	// Pixel was drawn before and nothing new was drawn
	return false;
}
</pre>

<p>The video buffer is arranged in a top-down order.  The top left
corner has the coordinates (0, 0).  The bottom left corner has the
coordinates (<code>width - 1</code>, <code>height - 1</code>).
The X coordinate is a simple addition to the pixel pointer.
Use the <code>ScanLine</code> function to convert a Y coordinate
into a pixel pointer.

<p><b>Example</b><br>
Sets the pixel at (10, 5) to black.

<pre>
Pixel	*line5 = ScanLine( info.pixel, 5, width, height );

line5[10].r = 0;
line5[10].g = 0;
line5[10].b = 0;
</pre>

</div>

<h2><a name="DrawInfo Structure">DrawInfo Structure</a></h2>
<p>

<div class="in">
<p><b>Declaration</b><br>
<pre>
struct DrawInfo
{
	DeviceContext	imageDC;
	RenderContext	imageRC;
	Pixel		*pixel;
	DrawState	state;
	double		time;
	float		*waveform;
	float		*frequency;
};
</pre>

<p><b>Purpose</b><br>
This structure is passed to the
<a href="#Visual::Draw"><code>Draw</code></a> function
to provide the video buffer, audio amplitude and frequency data,
elapsed time, and the current drawing state.

<p>The visual <b>must not</b> store any of the information
in this structure internally.  All these variables
will be invalid once the
<a href="#Visual::Draw"><code>Draw</code></a> function
returns.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>imageDC</code>
</td>
<td>
	A device context for using Windows GDI functions, such as
	SelectObject, LineTo, PatBlt, etc.
</td>
</tr>

<tr>
<td valign=top>
	<code>imageRC</code>
</td>
<td>
	A render context for using OpenGL functions, such as
	wglMakeCurrent.  Note that this value may be 0 if OpenGL
	is disabled.  A host program may have to disable OpenGL
	due to numerous	defective video drivers.

	<p>The Spinning Logo visual in GoldWave is an OpenGL
	visual.

	<p>Note: GoldWave v5.09 and later disables OpenGL by default
	(due to NVIDIA's video "driver mismatch" defect and Logitech's
	incompatible "game compatibility mode" mouse driver).
	Use <b>Start | All Programs | GoldWave | GoldWave Setup</b> to enable.

</td>
</tr>

<tr>
<td valign=top>
	<code>pixel</code>
</td>
<td>
	A pointer to the video buffer.  See the
	<a href="#Pixel Structure">Pixel Structure</a> section
	for more information.
</td>
</tr>

<tr>
<td valign=top>
	<code>state</code>
</td>
<td>
	Specifies the state of the host program.  It is one of the
	following values:

	<p><table align="center" border="0" width="100%" cellpadding=2>
	<tr><th align=left>Value</th><th align=left>Purpose</th></tr>
	<tr><td valign=top>dsStopped</td><td>No audio is being played or recorded.
	Usually the <code>waveform</code> and <code>frequency</code>
	members will be NULL.
	The visual should return to its rest state.</td></tr>
	<tr><td valign=top>dsPaused</td><td>Recording or playback is paused.  The
	visual should be frozen, showing the same audio data.</td></tr>
	<tr><td valign=top>dsActive</td><td>Recording or playback is active.  The
	visual should draw the latest audio data.</td></tr>
	<tr><td valign=top>dsInstant</td><td>An "instant" graph must be drawn using
	the latest audio data.  This occurs in GoldWave when the user drags
	the start or finish marker over the waveform.  The audio data
	is considered to be discontinuous (not related to any
	previous audio).</td></tr>
	</table>

</td>
</tr>

<tr>
<td valign=top>
	<code>time</code>
</td>
<td>
	Specifies the current elapsed time relative to the beginning of
	the file.  GoldWave also uses this
	to display a countdown timer for delayed recording.  Any visuals
	must be able to handle time increasing or decreasing.
</td>
</tr>

<tr>
<td valign=top>
	<code>waveform</code>
</td>
<td>
	Pointer to an array that holds the audio amplitude values at
	the sampling rate given in the <code>samplingRate</code>
	<a href="#State Structure">State</a> variable.  The
	array contains the number of samples defined by
	the <code>Samples</code> constant.

	Amplitude values usually range from -1.0 to 1.0, but higher
	value are possible.
	This pointer may be NULL if no audio is being played or recorded
	(when <code>state == dsStopped</code>).

	Waveform data is not contiguous from one
	<a href="#Visual::Draw"><code>Draw</code></a> call to the next.
	It is a snapshot of the waveform at a given instant in <code>time</code>.  It may
	overlap previous data or it may skip some data.  It depends on the system load, frame rate,
	and the amount of processing needed to generate the audio.  Use the <code>time</code>
	value above to determine the absolute time for the waveform data.  By comparing <code>time</code>
	values between calls, contiguous data may be obtained.
</td>
</tr>

<tr>
<td valign=top>
	<code>frequency</code>
</td>
<td>
	Pointer to an array that holds the frequency magnitude values
	generated from a Fourier analysis of the waveform data.
	Values range from 0dB (full volume) down to -100dB (silence).
	The array contains the number of magnitudes defined by
	the <code>Frequencies</code> constant.
	This pointer may be NULL if no audio is being played or recorded
	(when <code>state == dsStopped</code>).

	<p>To determine
	the frequency of one of the magnitudes in the array, use the
	following equation:
	<pre>    frequency = index * samplingRate / Frequencies / 2</pre>

	<p>The first magnitude (index 0) in the array is the 0Hz, dc magnitude.
	For 44100Hz audio, second magnitude (index 1) is at frequency 21.5Hz,
	the third (index 2) is at 42Hz, and so on.

	Frequency data is not contiguous from one
	<a href="#Visual::Draw"><code>Draw</code></a> call to the next.  Use the
	<code>time</code> value above to determine the absolute time frame for
	the frequency data.
</td>
</tr>

</table>
</div>


<h2><a name="EventInfo Structure">EventInfo Structure</a></h2>
<p>This structure holds event specific information.

<div class="in">
<p><b>Declaration</b><br>
<pre>
struct EventInfo
{
	enum Type
	{
		MouseFlag = 0x100,
		MouseEnter, MouseLeave, MouseMove,
		MouseUp, MouseDown
	};

	int	type;
	union
	{
		struct { int x, y; unsigned buttons; } mouse;
		char reserved[128];
	};
};
</pre>

<p><b>Purpose</b><br>
<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>Type</code>
</td>
<td>
	This enumeration lists groups of events.  The first item
	in the group is a flag indicating what group the event
	belongs to and what structure to use.  It can be used as
	follows:
<pre>
	if ( event.type &amp; MouseFlag )
		// Process a mouse event using the 'mouse' structure.
</pre>
</td>
</tr>

<tr>
<td valign=top>
	<code>type</code>
</td>
<td>
	Specifies the individual event type.  It is one of the <code>Type</code>
	values.

	<p><table align="center" border="0" width="100%" cellpadding=3>
	<tr><th align=left>Value</th><th align=left>Structure</th><th align=left>Purpose</th></tr>
	<tr><td valign=top>MouseEnter</td><td valign=top>mouse</td><td>The mouse has entered the visual's area.
	All members of the <code>mouse</code> structure are set.</td></tr>
	<tr><td valign=top>MouseLeave</td><td valign=top>mouse</td><td>The mouse has exited the visual's area.
	The <code>mouse.buttons</code> member contains button states, the other members are zero.</td></tr>
	<tr><td valign=top>MouseMove</td><td valign=top>mouse</td><td>The mouse has moved while in the visual's area.
	All members of the <code>mouse</code> structure are set.</td></tr>
	<tr><td valign=top>MouseUp</td><td valign=top>mouse</td><td>The mouse button was released.
	All members of the <code>mouse</code> structure are set.</td></tr>
	<tr><td valign=top>MouseDown</td><td valign=top>mouse</td><td>The mouse button was pressed.
	All members of the <code>mouse</code> structure are set.</td></tr>
	</table>

</td>
</tr>

<tr>
<td valign=top>
	<code>anonymous union</code>
</td>
<td>
	This contains a number of different structures depending on
	the event group.  Currently only one event group is defined
	for mouse events.
	<p><table align="center" border="0" width="100%" cellpadding=2>
	<tr><th align=left>Member</th><th align=left>Purpose</th></tr>
	<tr><td valign=top>mouse</td><td>Mouse information structure.</td></tr>
	<tr><td valign=top>mouse.x</td><td>The horizontal mouse position.</td></tr>
	<tr><td valign=top>mouse.y</td><td>The vertical mouse position.</td></tr>
	<tr><td valign=top>mouse.buttons</td><td>The mouse button state.  1 = left button down.
	  No other buttons are supported at this time.  The right button may be used
	  by the host program for setting visual properties.</td></tr>
	</table>
</td>
</tr>

<tr>
<td valign=top>
	<code></code>
</td>
<td>

</td>
</tr>

</table>
</div>



<h2><a name="Visual::SetState">SetState</a></h2>
<p>This function is called by the host program to change one
or more of the visual's <a href="#State Structure">State</a>
variables.

<div class="in">
<p><b>Declaration</b><br>
<code>void gdecl Visual::SetState( const State &amp;set, unsigned int flags );</code>

<p><b>Purpose</b><br>
When the size, rate, or other state variables change, the host
program calls this function to inform the visual about the change.
One or more of the state variables may be changed, depending on
the <code>flags</code> parameter.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Parameter</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>set</code>
</td>
<td>
	Provides new <a href="#State Structure">State</a>
	information.  The visual must check the <code>flags</code>
	parameter to determine what variables are valid.  It
	must not access or use any variables that are not
	set in the flags.
</td>
</tr>

<tr>
<td valign=top>
	<code>flags</code>
</td>
<td>
	Defines what <a href="#State Structure">State</a> variables
	have changed (and are valid) in the <code>set</code> parameter.
	The host program must set flags <b>only</b> for variables that have
	changed since the last call.  Typically, the first call by
	the host program would use the <code>sfAll</code> value.

	<p>It may be any ORed combination of the following flags:

	<p><table align="center" border="0" width="100%" cellpadding=1>
	<tr><th align=left>Value</th><th align=left>Purpose</th></tr>
	<tr><td>sfWidth</td><td>The width is valid and has changed.</td></tr>
	<tr><td>sfHeight</td><td>The height is valid and has changed.</td></tr>
	<tr><td>sfChannels</td><td>The number of channels is valid and has changed.</td></tr>
	<tr><td>sfSide</td><td>The side is valid and has changed.</td></tr>
	<tr><td>sfSamplingRate</td><td>The sampling rate is valid and has changed.</td></tr>
	<tr><td>sfPlaybackState</td><td>The playback state is valid and has changed.</td></tr>
	<tr><td>sfRecordState</td><td>The record state is valid and has changed.</td></tr>
	<tr><td>sfFrameRate</td><td>The frame rate is valid and has changed.</td></tr>
	<tr><td>sfFileInfo</td><td>The file information is valid and has changed.</td></tr>
	<tr><td>sfAll</td><td>All items are valid and have changed.</td></tr>
	</table>

</td>
</tr>

</table>


<p>A multithreaded host program must ensure it does not call this
function on one thread while another thread is in the middle of a
<a href="#Visual::Draw">Draw</a> call.  It must serialize
access to the visual.  This prevents major changes (such as width
and height changes) from occurring in the middle of drawing.
Also the host program must ensure it does not alter the device
context, render context, or video buffer on a separate thread
during a <a href="#Visual::Draw">Draw</a> call.

<p>A maximum of two thread may be used for visuals.  One for
the <a href="#Visual::Draw">Draw</a> call and one for all other
calls.  <code>SetState</code> can be called only when no
other thread is using the visual.
</div>


<h2><a name="Visual::Draw">Draw</a></h2>
<p>

<div class="in">
<p><b>Declaration</b><br>
<code>bool gdecl Visual::Draw( DrawInfo &amp;info );</code>

<p><b>Purpose</b><br>
This host program calls this function rapidly to update the audio
data for the visual.  The visual may graph the audio data, display
statistical information, show the elapsed time, show the current
playback and recording status, display file information, or display
any other graphical information.  This is very similar to the
painting a window during a WM_PAINT message, except that
it occurs at a fixed interval whether the windows needs painting
or not.

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Parameter</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>info</code>
</td>
<td>
	Contains the current audio information and video buffer.
	See the <a href="#DrawInfo Structure">DrawInfo Structure</a>
	for more information.
</td>
</tr>
</table>

<p>When drawing Level and Graph visuals, care must be taken to
account for the variable window size.  The window size can change
at any time between <code>Draw</code> calls through a call to
<a href="#Visual::SetState"><code>SetState</code></a>.  Visuals
must scale graphs or meters appropriately to fit within the
window.

<p>The <a href="#State Structure">State</a> structure, which is part
of the Visual class, includes the current width and height and other
information, like playback/recording states, needed to draw the visual.

<p>Host programs may call this function 200
times per second (though it is usually 30 to 60 times per second).
Therefore it is important that
drawing be as efficient as possible to reduce processor load.

<ul>
<li>Use the <code>refresh</code> <a href="#State Structure">State</a>
variable to determine when the entire video buffer must be updated
and when only the audio graph/information itself needs updating.
<li>Check the <code>info.state</code> value.  If it is <code>dsStopped</code>
the visual must begin returning to its rest state.  Once it is at its
rest state, it should avoid any updates to the video buffer and
return false.
<li>If nothing has changed from one call to the next or no changes
have been made to the video buffer, return false so the host program will
not have to copy the video buffer to the screen.
<li>Optimize code as much as possible.  If the visual cannot run
at real-time on slower systems, it should skip frames or ignore
every second <code>Draw</code> call (except when <code>info.refresh</code>
is true).
</ul>

<p style="color:#C00000;font-weight:bold">Important: Do
not store any of the information contained in the <code>info</code>
parameter across calls (except <code>time</code> and <code>state</code>).
Do not reuse old
<code>imageDC</code> or <code>imageRC</code> values and make sure
that all GDI or OpenGL objects are released before returning.
Failure to restore these to their original state and free
all resources could leave the host program in an unstable state
or cause severe resource leaks.  Be sure to monitor memory and
resource usage during testing.</p>

Drawing can be performed by accessing the <code>pixel</code>
video buffer directly, by calling Windows GDI functions with
<code>imageDC</code>, or by calling OpenGL functions after
setting the current render context to <code>imageRC</code>.
Note that the Windows <code>GdiFlush</code> call may be required after
making GDI calls before directly accessing the buffer.

For simple direct buffer examples, see the
<a href="#Pixel Structure">Pixel Structure</a> section.

<p><b>Example</b><br>
Uses the Windows GDI to clear the video buffer.

<pre>
#include "gwvisual.h"
using namespace Gvp;

// ...

bool gdecl ClearVisual::Draw( DrawInfo &amp;info )
{
	// Make sure the video buffer is valid
	if ( width &lt;= 0 || height &lt;= 0 )
		return false;

	if ( refresh )	// Don't clear buffer every time (be efficient)
	{
		HBRUSH  hbr = CreateSolidBrush( 0 ), oldbr;

		oldbr = (HBRUSH)SelectObject( info.imageDC, hbr );

		PatBlt( info.imageDC, 0, 0, width, height, PATCOPY );

		SelectObject( info.imageDC, oldbr );
		DeleteObject( hbr );

		refresh = false;
		return true;
	}

	// Buffer was cleared before and nothing new was drawn
	return false;
}
</pre>

<p><b>Example</b><br>
Demonstrates how to use OpenGL.
All OpenGL visuals share the same render context.  For complex
visuals, a separate rendering thread must be created to maintain
separate OpenGL object and state data.  Note that the rendering
thread must complete rendering before the <code>Draw</code> function
returns so that the <code>imageRC</code> can be released.
Also the Windows <code>GdiFlush</code> function must be called
before returning.

<pre>
#include "gwvisual.h"
using namespace Gvp;

// ...

bool gdecl OpenGLVisual::Draw( DrawInfo &amp;info )
{
	// Make sure the video buffer is valid
	if ( width &lt;= 0 || height &lt;= 0 )
		return false;

	if ( info.imageRC )
	{
		wglMakeCurrent( info.imageDC, info.imageRC );

		/*
		   Do all OpenGL rendering here or use a SetEvent call
		   to activate an independent thread to do the rendering
		   and wait for the thread to complete.
		 */

		wglMakeCurrent( 0, 0 );
		GdiFlush();
		return true;
	}
	else if ( refresh )
	{
		/*
		   If OpenGL is not available and a refresh is required,
		   clear the buffer manually (or use GDI).
		 */
	}

	// Nothing new drawn
	return false;
}
</pre>

<p><b>Example</b><br>
Demonstrates how to use Borland's VCL <code>TCanvas</code>.  A
<code>TCanvas</code> object
must be created in the visual's constructor and deleted it
its destructor.

<pre>
#include "gwvisual.h"
using namespace Gvp;

// ...

bool gdecl VCLVisual::Draw( DrawInfo &amp;info )
{
	bool updated = false;

	Canvas-&gt;Handle = info.imageDC;
	Canvas-&gt;Lock();
	try
	{
		// Draw using the Canvas object...

		// Set the 'updated' value accordingly
	}
	__finally
	{
		Canvas-&gt;Unlock();
		Canvas-&gt;Handle = 0;
	}
	return updated;
}
</pre>

</div>

<h2><a name="Visual::Event">Event</a></h2>
<p>This function is used to pass an event to the visual.

<div class="in">
<p><b>Declaration</b><br>
<code>int gdecl Visual::Event( EventInfo &amp;event );</code>

<p><b>Purpose</b><br>
The host program calls this function when a user interface event
occurs within the visual, such as a mouse movement, a mouse click,
or a key press (not implemented yet).

<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Parameter</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code>event</code>
</td>
<td>
	Contains information about the user interface event.
	See the <a href="#EventInfo Structure">EventInfo Structure</a>
	section for more information.
</td>
</tr>
</table>

<p>Since no context/video buffer information is given, the visual cannot
(and must not) redraw itself during an event.  It must wait until
the next <a href="#Visual::Draw">Draw</a> call to update the
video buffer.  The visual should store the current event information
so that it can be used later.  See the <code>SampleMouse</code> code
in the <code>SampleVisual</code> example for more information.

</div>

<h2><a name="Visual Host Program Usage">Host Program Usage</a></h2>

<p>The host program loads the Visual module then calls the
<a href="#Interface Function">Interface Function</a> to get a pointer to
the <a href="#Interface Structure">Interface Structure</a>.

<p>The host program performs the following steps when creating
and using a visual:

<ol>
<li>It checks the <a href="#Visual::abilities"><code>abilities</code></a>
in the <a href="#Interface::list"><code>Interface::list</code></a> table to
ensure all bits are supported and determines what locations the
visual supports.

<li>It calls the <a href="#Interface::create"><code>Interface::create</code></a>
function to create the visual object based on its
<a href="#Visual::name"><code>name</code></a>
in the <a href="#Interface::list"><code>Interface::list</code></a> table.

<li>If the <code>aPage</code>
<a href="#Visual::abilities"><code>ability</code></a>
is set, it calls the
<a href="#PluginObject::Set"><code>Set</code></a>
function to set any previous settings.

<li>It constructs a 16 bit colour bitmap image for rendering.

<li>It calls the <a href="#Visual::SetState"><code>SetState</code></a>
function to initialize all of the state variables.

<li>It starts calling the
<a href="#Visual::Draw"><code>Draw</code></a> function repeatedly at
the frame rate given in the <a href="#State Structure">State Structure</a>.

<li>It occasionally calls <a href="#Visual::SetState"><code>SetState</code></a>
(between <a href="#Visual::Draw"><code>Draw</code></a> calls) to
update state information, such as when the visual window is resized.

<li>If the <code>aPage</code>
<a href="#Visual::abilities"><code>ability</code></a>
is set, it may call the
<a href="#PluginObject::GetPage"><code>GetPage</code></a> function
and host the visual's page in its own window.  This may occur
at the same time that
<a href="#Visual::Draw"><code>Draw</code></a> calls occur.

<li>If the <code>aEvent</code>
<a href="#Visual::abilities"><code>ability</code></a>
is set, it calls the <a href="#Visual::Event"><code>Event</code></a>
function when user interface events occur.
The host program must not call this function at the same time a
<a href="#Visual::Draw"><code>Draw</code></a> calls occur.

<li>It destroys the visual when it is no longer needed.

</ol>

<h1><a name="Building">Compiling, Installing, and Testing</a></h1>
<p>This section provides information for building and deploying
plug-ins.

<h2><a name="Compiling">Compiling</a></h2>
<p>Unfortunately the
C++ standard does not provide an implementation standard for class layout,
so care must be taken to ensure that plug-in objects compiled with
different compilers are compatible with host programs.

<ul>
<li> A derived class must not have any virtual base classes.  Otherwise
any compatibility between Borland and Microsoft virtual table layout
may be destroyed.
<li> Structure padding and alignment must be double word (4 bytes).
<li> UNICODE must be defined so that TCHAR is wchar_t (WCHAR)
<li> The standard C calling convention must be used (parameters are
stacked right to left, and the caller cleans up the stack).  Use
<b>gdecl</b> for all plug-in member functions.
<li> <code>enum</code> values must be the size of an <code>int</code> (4 bytes).
<li> Exceptions must be handled internally within the plug-in.  Exceptions
must not pass to the host program where the exception handling implementation
may be different.
<li> The <a href="#Interface Function">interface function</a> must
be exported.  That is handled by the macros included in the header files.
<li> Remember to add the appropriate <code>include</code> path
"<code>gwplugin/include</code>" to a project so that the plug-in
header files can be found.
<li> Plug-ins must not leave any masked "floating exception"
in the FPU and must not alter the control word.
<li> Create a project for building a DLL, not an application.  The
filename extension for the DLL must be set to <b><code>.pig</code></b>
(<b style="color:red">P</b>lug-<b style="color:red">I</b>n
for <b style="color:red">G</b>oldWave).
</ul>

It is strongly recommended that static linking be used when possible,
unless other DLLs used are already included with Windows.  Ideally, the
plug-in module should consist of a single module.  If additional DLLs
are needed, then should be installed in the appropriate plug-in
folder.

<h2><a name="Installing">Installing</a></h2>
<p>Installing a plug-in usually just involves copying the plug-in module
(with the <b><code>.pig</code></b> extension), any help
files, and any support DLLs to the appropriate host program plug-in folder.  In GoldWave, for example,
there are
three subfolders where the program itself is installed: <code>Effect</code>,
<code>File</code>, and <code>Visual</code>.  By copying the
plug-in files to the correct folder, GoldWave
will detect and use it the next time the program is started.

<p style="color:#C00000;font-weight:bold">Be sure to name modules
uniquely so that they do not overwrite or conflict with existing modules.</p>

<p>Module filenames should contain a company name or initials, such
as "MyCompanyFX.pig" or "MC-FXPack.pig".

<h2><a name="Testing">Testing</a></h2>

<div class="in">
<h3><a name="Effect Testing">Effect Testing</a></h3>

<ul>
<li>
Make sure that the <a href="#Effect::Read"><code>Read</code></a>
function does not attempt to read more than <code>MaxSamples</code> in a
single call.

<li>
Be sure to modify only the channels with flags set under
the <a href="#Transform::channel"><code>channel</code></a> member.

<li>
If implementing a <a href="#Page">Page</a> interface,
make sure that that appropriate default setting are assigned when
the plug-in is created.  Make sure that if a different preset is
selected in the host program, the settings are updated on the page.

<li>
In GoldWave, an Effect plug-ins should be tested through the Effect
menu, the Chain Editor (if the effect is compatible) and the
Batch Processor.  Use a variety of files with different sampling
rates and channels.  Run tests with only one channel
selected.  Also test previewing
and changing setting while previewing.  Restart previewing to
ensure the effect is being <a href="#Transform::Reset"><code>Reset</code></a>
properly.  Check to make sure the elapsed time displayed in
GoldWave's Control window is correct.
</ul>

<h3><a name="File Format Testing">File Format Testing</a></h3>

<ul>
<li>
Make sure the module's <a href="#Plug-in Creator Function">creator function</a>,
when passed a filename, correctly rejects file formats the module
cannot handle and accepts ones it can handle.

<li>
Make sure plug-ins do not crash when given corrupt, truncated, or
extended files.

<li>
In GoldWave, use the Batch Processing feature to test with a
variety of files with different sampling rates and channels.
Also ensure that file types and attributes are listed properly
for each of the plug-ins in the module.
</ul>

<h3><a name="Visual Testing">Visual Testing</a></h3>

<ul>
<li>
Make sure GDI resources are freed (in Windows, use SelectObject to restore all
default objects).  Operate the visual for a long
period of time and use the Windows resource meter or task manager
to monitor resource usage to ensure it does not steadily increase.

<li>
Make sure that waveform data outside the range of -1.0 to 1.0 is
handled/clipped appropriately and no attempt is made to draw outside
the visual's buffer.

<li>
If using OpenGL, be sure to return the rendering context to its
default state (or use a separate thread instead).  Note that
a host program may disable OpenGL due to driver problems, so
check that the context is valid.

<li>
In GoldWave, test the visual in each of the locations that the
visual supports (status, level, left, and/or right).  Test
with a variety of files with different sampling rates and
channels.  If graphing a single channel, use the Balance
fader to test that the correct channel is being drawn.
Use the <b>Start | Programs | GoldWave | GoldWave Setup</b> feature
to disable OpenGL for testing.
</ul>

</div>

<h1><a name="Simplified Plug-ins">Simplified Plug-in SDK</a></h1>
<p><b>This section is under development and is incomplete!</b>

<p>The following sections give details on a simplified version of the
plug-in SDK.  It does not require using C++.  The plug-ins can be
developed in C or potentially other languages.  Only a number of
manditory functions have to be created.  All functions and structures
use the standard Windows calling convention (<code>STDMETHODCALLTYPE</code>)
and byte alignment, eliminating problems with compiler differences.
Use standard Windows settings when
creating these plug-ins.  The compiling information in the previous
section does not apply.  Only the <code>sgwsdk.h</code> file needs to be
included.  Make sure all required functions are
exported (use __export or __declspec(dllexport) or an export file).

<h2><a name="Simple Common Functions">Common Functions and Structures</a></h2>
<p>Different types of plug-ins use the same functions and structures
to achieve the same tasks.  These include things like creating an
instance of the plug-in, setting properties, working with file
information, or working with cue points.  These common functions and structures
are explained in the following sections.

	<div class="in">
	<h3><a name="Simple Plug-in Functions">Plug-in Functions</a></h3>
	<p>Functions for creating, destroying, and describing a plug-in are
	manditory and must exist in all plug-in modules.  Functions to get
	or set properties are optional and depend on the presence of the
	<code>gw_aPage</code> ability flag.  The core functions are explained
	below.

	<p><b>Declaration</b><br>
	<code>void * STDMETHODCALLTYPE gw_Construct( void );</code>

	<p><b>Purpose</b><br>
	Creates an instance of the plug-in.  The pointer returned
	points to instance specific data for the plug-in.  It is used
	in all other calls.  Global instance data must not be used because
	several copies of a plug-in may be created and used by the host
	program at the same time.  Each copy must be independent.  The
	contents of the instance data is up to the developer and depends
	on the type of plug-in created.

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>void STDMETHODCALLTYPE gw_Destroy( void *instance );</code>

	<p><b>Purpose</b><br>
	Destroys or frees an instance of the plug-in.  The <code>instance</code>
	parameter is the pointer to the instance data returned by the
	<code>gw_Construct</code> function.

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>const wchar_t * STDMETHODCALLTYPE gw_Name( void );</code>

	<p><b>Purpose</b><br>
	Returns the name of the plug-in.  The host program displays
	this name on the menu, so use a meaningful name.

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>unsigned STDMETHODCALLTYPE gw_Ability( void );</code>

	<p><b>Purpose</b><br>
	Returns the ability flags of the plug-in.  See the <code>gw_a*</code>
	defines in the <code>sgwsdk.h</code> file.
	For the simple SDK, all flags must be prefixed with <code>gw_</code>,
	such as <code>gw_aPage</code>.
	Different plug-ins have
	different ability flags.  See
	<a href="#AudioFile::abilities">Audio File Abilities</a>
	(prefix <code>gwa_</code>),
	<a href="#Effect::abilities">Effect Abilities</a>
	(prefix <code>gwe_</code>), and
	<a href="#Visual::abilities">Visual Abilities</a>
	(prefix <code>gwv_</code>).

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>int STDMETHODCALLTYPE gw_Get( void *instance, void *data, int size );</code>

	<p><b>Purpose</b><br>
	Gets the settings or properties for the plug_in.
	The <code>gw_Ability</code>
	function must include the <code>gw_aPage</code> flag to support
	settings.  The
	<code>instance</code> parameter points to the instance data
	returned by the <code>gw_Construct</code> function.

	<p>To determine
	the size of the buffer needed to hold the properties, the host
	program first calls this function with
	<code>data</code> and <code>size</code>
	set to zero.  The function must return the size in bytes required
	to store all settings.

	<p>The host program calls this function a second time with
	<code>data</code> pointing to a buffer large enough to hold the
	settings.  The <code>size</code> parameter gives the size of the buffer,
	which is the same value returned by this function in the first
	call.

	<p>Returns the number of bytes stored.

	<p>This function also is called by
	the host program just before calling the <code>gw_Set</code> function to
	determine how much data to load and pass to that function.

	<p><b>Requirement</b><br>
	Required only if the <code>gw_aPage</code> flag is returned by the
	<code>gw_Ability</code> function.  Requires <code>gw_Set</code>.
	Additional page related functions
	are required as well.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>int STDMETHODCALLTYPE gw_Set( void *instance, void *data, int size );</code>

	<p><b>Purpose</b><br>
	Sets the settings or properties for the visual.
	The <code>gw_Ability</code>
	function must include the <code>gw_aPage</code> flag to support
	settings.  The
	<code>instance</code> parameter points to the instance data
	returned by the <code>gw_Construct</code> function.

	<p>To determine the amount of data expected for this function,
	the host program first calls the <code>gw_Get</code> function with
	<code>data</code> and <code>size</code>
	set to zero.  That function must return the size in bytes for the
	all settings.

	<p>The host program calls this function with
	<code>data</code> pointing to a buffer containing all the settings.
	The <code>size</code> parameter gives the size of the buffer in bytes.

	<p>If a page is shown, controls on that page must be updated with the
	new settings.

	<p>Returns TRUE if all settings are compatible and valid.

	<p><b>Requirement</b><br>
	Required only if the <code>gw_aPage</code> flag is returned by the
	<code>gw_Ability</code> function.  Requires <code>gw_Get</code>.
	Additional page related functions
	are required as well.

	</div>

	<div class="in">
	<h3><a name="Simple Page Functions">Page Functions</a></h3>
	<p>Plug-ins that have settings or properties must implement
	the <code>gw_Get</code>	and <code>gw_Set</code> functions
	as well as a number
	of page functions.  The page functions are explained below.  These functions
	are required only if the <code>gw_aPage</code> ability flag is returned
	by a plug-in's <code>gw_Ability</code> function.

	<p><b>Declaration</b><br>
	<code>void * STDMETHODCALLTYPE gw_PageConstruct( void *instance );</code>

	<p><b>Purpose</b><br>
	Creates a properties page for the given <code>instance</code> of
	a plug-in.  The pointer returned
	points to instance specific data for the page.  It is used
	in all other page related calls.  The contents of the instance
	data is up to the developer, but it must be allocated memory and not
	global/static memory since different instances of the page may
	be created for different instances of the plug-in.  At a minimum,
	it may include the <code>instance</code> plug-in pointer and
	a window handle.

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>void STDMETHODCALLTYPE gw_PageDestroy( void *page );</code>

	<p><b>Purpose</b><br>
	Destroys or frees the given instance of a properties page.
	The <code>page</code> parameter is a pointer to the instance data of
	the page, obtained from the <code>gw_PageConstruct</code>
	call.

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>HWND STDMETHODCALLTYPE gw_PageHandle( void *page, HWND parent );</code>

	<p><b>Purpose</b><br>
	Assigns the parent window for the page and returns the window handle
	of the new page.  This function may be used to create the window for
	the properties page.  See <a href="#Page::Handle"><code>Handle</code></a>
	for more details.

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>void STDMETHODCALLTYPE gw_PageShow( void *page );</code>

	<p><b>Purpose</b><br>
	Makes the window visible.  In Windows, the <code>ShowWindow</code>
	function would be used with the SW_SHOW value.  The <code>Page</code>
	parameter is page instance data.

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>void STDMETHODCALLTYPE gw_PageHide( void *page );</code>

	<p><b>Purpose</b><br>
	Hides the window.  In Windows, the <code>ShowWindow</code>
	function would be used with the SW_HIDE value.  The <code>Page</code>
	parameter is page instance data.

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>const wchar_t * STDMETHODCALLTYPE gw_PageHelp( void *page );</code>

	<p><b>Purpose</b><br>
	Returns a string indicating the location of help.  See
	<a href="#Page::Help"><code>Help</code></a>.

	<p><b>Requirement</b><br>
	Optional.  Include the <code>gw_paHelp</code> flag
	in the <code>gw_PageAbility</code> function so the host program will
	display a Help button.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>void STDMETHODCALLTYPE gw_PageUpdate( void *page );</code>

	<p><b>Purpose</b><br>
	Performs command enabling or idle processing.  See
	<a href="#Page::Update"><code>Update</code></a>.

	<p><b>Requirement</b><br>
	Optional.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>BOOL STDMETHODCALLTYPE gw_PageApply( void *page );</code>

	<p><b>Purpose</b><br>
	Applies the current settings to the plug-in.  This function is
	called by the host program when the Apply button is clicked.  See
	<a href="#Page::Apply"><code>Apply</code></a>.

	<p><b>Requirement</b><br>
	Optional.  Include the <code>gw_paApply</code> flag
	in the <code>gw_PageAbility</code> function so the host program will
	display an Apply button.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>void STDMETHODCALLTYPE gw_PageResize( void *page, int width, int height );</code>

	<p><b>Purpose</b><br>
	Resizes or recenters the page to the size given by <code>width</code>
	and <code>height</code>.
	The host program calls this function to inform the page that the
	parent window has been resized.  See
	<a href="#Page::Resize"><code>Resize</code></a>.

	<p><b>Requirement</b><br>
	Optional.  Include the <code>gw_paResize</code> flag
	in the <code>gw_PageAbility</code> function so the host program will
	create a resizeable parent window.  This function (if implemented)
	is called by the host after the page is created, even if the flag
	is not included, so the page can center itself in the parent client
	area.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>int STDMETHODCALLTYPE gw_PageWidth( void *page );</code><br>
	<code>int STDMETHODCALLTYPE gw_PageHeight( void *page );</code>

	<p><b>Purpose</b><br>
	Returns the width and height of the page.
	The host program calls these function to determine the minimum width
	and height of the parent window client area.  These functions
	are called after the <code>gw_PageHandle</code> call.

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>unsigned STDMETHODCALLTYPE gw_PageAbility( void );</code>

	<p><b>Purpose</b><br>
	Returns the page ability flags.  See
	<a href="#Page::abilities"><code>Ability</code></a>.
	For the simple SDK, all flags must be prefixed with <code>gw_</code>,
	such as <code>gw_paHelp</code>.

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	</div>

	<div class="in">
	<h3><a name="Simple Metadata Structure">Metadata Structure</a></h3>
	<p>Plug-ins that display or manipulate non-audio data use the
	<code>gw_Metadata</code> structure.

<pre>
typedef struct taggw_Metadata
{
	void *list;
	/* TBD */
} gw_Metadata;
</pre>

	<p>The <code>list</code> item is an opaque object that cannot be directly
	modified by the plug-in.  See the <code>gwm_*</code> defines
	in the <code>sgwsdk.h</code> header file.  Also
	see <a href="#Metadata Class">Metadata</a> for more information.

	<p><b>Example</b><br>
	Gets and sets the author.
<pre>
const wchar_t *author = metadata-&gt;GetText( metadata-&gt;list, GWText_Author );
metadata-&gt;SetText( metadata-&gt;list, GWText_Author, L"GoldWave Inc." );
</pre>
	</div>


	<div class="in">
	<h3><a name="Simple InfoList Structure">InfoList Structure [Deprecated]</a></h3>
	<p>Plug-ins that display or manipulate file information use the
	<code>gw_InfoList</code> structure.

<pre>
typedef struct taggw_InfoList
{
	void *list;
	const wchar_t * CALLBACK (*Get)( void *list, int item );
	BOOL CALLBACK (*Set)( void *list, int item, const wchar_t *string );
} gw_InfoList;
</pre>

	<p>The <code>list</code> item is an opaque object that cannot be directly
	modified by the plug-in.  Instead the <code>Get</code> and <code>Set</code>
	callback function pointers must be used to add or modify
	information in the list.  The <code>list</code> pointer must be used as
	the first parameter in all calls.

	<code>Get</code> returns a constant string for the file information
	indicated by the <code>item</code> parameter.  <code>Set</code> sets the
	file information for the item.  The <code>string</code> parameter can be
	NULL to erase the item.  See the <code>gwi_*</code> defines
	in the <code>sgwsdk.h</code> header file.  Also
	see <a href="#Metadata Class">Metadata</a> for more information.

	<p><b>Example</b><br>
	Gets and sets the author.
<pre>
const wchar_t *author = metadata-&gt;Get( metadata-&gt;list, GWText_Author );
metadata-&gt;Set( metadata-&gt;list, GWText_Author, L"GoldWave Inc." );
</pre>
	</div>

	<div class="in">
	<h3><a name="Simple CueList Structure">CueList Structure</a></h3>
	<p>Plug-ins that display or manipulate cue points use the
	<code>gw_CueList</code> and <code>gw_Cue</code> structures.

<pre>
typedef struct taggw_Cue
{
	double		position;
	const wchar_t	*name, *description;
}gw_Cue;

typedef struct taggw_CueList
{
	void *list;
	BOOL CALLBACK (*Add)( void *list, const gw_Cue *cue );
	BOOL CALLBACK (*Set)( void *list, int index, const gw_Cue *cue );
	BOOL CALLBACK (*Get)( void *list, int index, gw_Cue *cue );
	BOOL CALLBACK (*Remove)( void *list, int index );
	int CALLBACK (*Count)( void *list );
} gw_CueList;
</pre>

	<p>The <code>list</code> item is an opaque object that cannot be directly
	modified by the plug-in.  Instead, the callback function pointers,
	explained below, must be used to add or modify cue point information.
	The <code>list</code> point must be used in all calls.
	See <a href="#CueList Class">CueList Class</a> for more information.

	<p>
	<table align="center" border="1" width="75%" cellpadding=3>
	<tr><th align=left>Function</th><th align=left>Purpose</th></tr>

	<tr>
	<td valign=top>
		<code>Add</code>
	</td>
	<td>
		Adds a new cue point to the list.  The <code>cue</code> parameter must
		contain a fully initialized <code>gw_Cue</code> structure.
		Returns TRUE if the cue is added successfully.  FALSE is
		returned if there is insufficient memory.
	</td>
	</tr>

	<tr>
	<td valign=top>
		<code>Set</code>
	</td>
	<td>
		Updates an existing cue point at the given <code>index</code>
		with new data.
		The <code>cue</code> parameter must
		be a pointer to a fully initialized <code>gw_Cue</code> structure.
		Returns TRUE if the cue is updated successfully.  FALSE is
		returned if there is insufficient memory or the index is
		out of range.
	</td>
	</tr>

	<tr>
	<td valign=top>
		<code>Get</code>
	</td>
	<td>
		Retrieves an existing cue point at the given <code>index</code>
		The <code>cue</code> parameter must
		point to an empty <code>gw_Cue</code> structure.  Strings returned
		in the structure <b>must not</b> be altered in any way and should be
		considered temporary.
		Returns TRUE if the cue is retrieved successfully.  FALSE is
		returned if the index is out of range.
	</td>
	</tr>

	<tr>
	<td valign=top>
		<code>Remove</code>
	</td>
	<td>
		Removes an existing cue point at the given <code>index</code>.
		Returns TRUE if the cue is deleted successfully.  FALSE is
		returned if the index is out of range.
	</td>
	</tr>

	<tr>
	<td valign=top>
		<code>Count</code>
	</td>
	<td>
		Returns the number of cue points currently in the list.
	</td>
	</tr>

	</table>

	<p><b>Example</b><br>
	Adds a cue point at 10 seconds, changes it to 20 seconds, then removes it.

	<pre>
gw_Cue	cue;
int	last = cuelist-&gt;Count( cuelist-&gt;list );

cue.position = 10.0;
cue.name = "Ten";
cue.description = NULL;
cuelist-&gt;Add( cuelist-&gt;list, cue );

cue.position = 20.0;
cue.name = "Twenty";
cuelist-&gt;Set( cuelist-&gt;list, last, cue );

cuelist-&gt;Remove( cuelist-&gt;list, last );
	</pre>
	</div>


<h2><a name="Simple Visual Plug-ins">Simple Visual Plug-ins</a></h2>
<p>To create a simple visual, one one additional manditory function must
be implemented.  Two other are optional depending on the ability
flags specified.  The functions are listed
<a href="#Simple Visual Functions">below</a>.  The structures used for the
functions are described next.

<div class="in">
<h3><a name="Simple Visual State Structure">State Structure</a></h3>
<p>

<p><b>Declaration</b><br>
<pre>
typedef struct taggwv_State
{
	int		width, height,
			channels,
			side,
			samplingRate,
			playbackState,
			recordState,
			frameRate;
	gw_Metadata	*metadata;
} gwv_State;
</pre>

<p>This structure is similar to the normal
<a href="#State Structure">State</a> structure.
See <a href="#State Structure">State Structure</a> and
<a href="#Simple Metadata Structure">Metadata Structure</a> for
more information.


<h3><a name="Simple Pixel Structure">Pixel Structure</a></h3>
A pixel structure is not defined for the simple SDK.  Pixels are 32 bit
values.  See the
<a href="#Pixel Structure">Pixel Structure</a> section for details about
how the pixels are stored.

<h3><a name="Simple DrawInfo Structure">DrawInfo Structure</a></h3>

<p><b>Declaration</b><br>
<pre>
typedef struct taggwv_DrawInfo
{
	HDC	  		imageDC;
	gwv_Pixel		*pixel;
	int	  		state;
	double			time;
	float			*waveform;
	float			*frequency;
} gwv_DrawInfo;
</pre>
<p>This structure is similar to the normal
<a href="#DrawInfo Structure">DrawInfo</a> structure, but without the OpenGL
context.  See the <a href="#DrawInfo Structure">DrawInfo Structure</a> section
for information about each item.

<h3><a name="Simple EventInfo Structure">EventInfo Structure</a></h3>
The simple <code>EventInfo</code> structure is same as the normal
<a href="#EventInfo Structure">EventInfo Structure</a> with the enumeration
replaced by defined constants.

<h3><a name="Simple Visual Functions">Simple Visual Functions</a></h3>
This section summarizes the functions required to create a simple
visual.  The <code>gw_Draw</code> and <code>gw_SetState</code>
functions are manditory.
Others are optional or depend on the features the plug-in
implements.

	<p><b>Declaration</b><br>
	<code>BOOL STDMETHODCALLTYPE gwv_Draw( void *instance, gwv_DrawInfo *draw );</code>

	<p><b>Purpose</b><br>
	Draws the visual on the pixel buffer given in <code>draw-&gt;pixel</code>
	or the device context given in <code>draw-&gt;imageDC</code>.
	The
	<code>instance</code> parameter points to the instance data
	returned by the <code>gw_Construct</code> function.  See
	<a href="#Visual::Draw">Draw</a> and
	<a href="#Simple DrawInfo Structure">DrawInfo Structure</a>.

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>void STDMETHODCALLTYPE gwv_SetState( void *instance, gwv_State *state, unsigned flags );</code>

	<p><b>Purpose</b><br>
	Provides state information for the visual, such as the width and
	height of the visual, the frame rate, playback and recording states, etc.
	The plug-in must store and update this information whenever this function
	is called by the host program.
	See
	<a href="#Visual::SetState">SetState</a> and
	<a href="#Simple Visual State Structure">State Structure</a>.

	<p><b>Requirement</b><br>
	Manditory.
	<p><hr>

	<p><b>Declaration</b><br>
	<code>void STDMETHODCALLTYPE gwv_Event( void *instance, gwv_EventInfo *event );</code>

	<p><b>Purpose</b><br>
	Called by the host program when a user interface event occurs, such
	as a mouse click.  See
	<a href="#Visual::Event">Event</a> and
	<a href="#Simple Visual EventInfo Structure">EventInfo Structure</a>.

	<p><b>Requirement</b><br>
	Required only if the <code>gwv_Event</code> flag is included in the
	<code>gw_Ability</code> function.


<h3><a name="Simple Visual Deployment">Simple Visual Deployment</a></h3>
<p>The visual must be distributed with the <code>SimpleVisualModule.pig</code>
file, which
must be renamed to match the name of the visual.  For example, if the visual
module is called <code>NewVisual.dll</code>, then the
<code>SimpleVisualModule.pig</code> must be renamed
to <code>NewVisual.pig</code>.
GoldWave will load the <code>NewVisual.pig</code> module, which in turn gets
the functions from the <code>NewVisual.dll</code> module.  Make sure all
required functions are exported (use __export or __declspec(dllexport)).

<h3><a name="Simple Visual Example">Simple Visual Example</a></h3>
<p>See <code>gwplugin\simple\examples\SampleVisual.c</code>
for an example of a simple visual
implemented with this SDK.  The visual displays a waveform and includes
a properties page to set the colours of the waveform and background.
Copy both the <code>SimpleVisual.dll</code> and <code>SimpleVisual.pig</code>
files into GoldWave's <code>Visual</code> folder.

</div>

<h1><a name="Tutorial">Tutorial</a></h1>
<p>Creating a plug-in involves two major steps with a number
of minor steps.  The major steps involve setting up the host
program interfaces and creating a derived plug-in object.  This
tutorial lists all the steps required to create a Mute effect.
See <code>Mute.cpp</code> for the complete code.

<h2><a name="Header Files, Namespace, and Entry Point">Header Files, Namespace, and Entry Point</a></h2>
<p>If developing under Windows, a DLL entry point function is required.
Namespaces should be used as well to minimize the need for the scope
resolution operator.  Inclusion of the <code>windows.h</code> header
file is needed only for the DllMain prototype.  Plug-ins do not require
that header file.  For more advanced effects, you may need to store the
instance handle for using resource strings and dialogs.

<pre>
#include &lt;windows.h&gt;	// Needed for DllMain function only
#include "gweffect.h"	// Effect plug-in base class (set include directory)

using namespace Gfx;	// Plug-in namespaces

BOOL WINAPI DllMain( HINSTANCE, DWORD, LPVOID )
{
	return 1;
}
</pre>

<h2><a name="Defining the Host Program Interface">Defining the Host Program Interface</a></h2>
<p>The Mute plug-in module contains only one effect called "Mute".  A
<a href="#Plug-in Table">table</a>,
a <a href="#Plug-in Creator Function">creator function</a>,
an <a href="#Interface Structure">interface structure</a>
and an <a href="#Interface Function">interface function</a> are required.

<ol>
<li> Create the table for the mute effect containing the effects name,
abilities, and icon.  The effect's name will be "Sample Mute".
The effect has no special abilities (0) and no icon exists (0).
<pre>
Table MuteTable = { L"Sample Mute", 0, 0 };
</pre>
<p>
<li> Create a plug-in creator function.  This function takes a name
of the plug-in and constructs the appropriate object:
<pre>
Effect * gdecl Create( const wchar_t *name )
{
	if ( name &amp;&amp; wcscmp( name, MuteTable.name ) == 0 )
		return new Mute;
	return 0;
};
</pre>
<p>This function needs to be placed after the Mute class definition.
<p>

<li> Create an interface structure by filling in all the required
members.  The version value is usually set to version defined in
the plug-in header file.  For effects, this is <code>EffectVersion</code>.
The number of plug-ins in the module is 1.  The
table is <code>MuteTable</code> as given above.  The plug-in creator
function is <code>Create</code> as given above.  There is no configuration
function.
<pre>
Interface MuteInterface = { EffectVersion, 1, &amp;MuteTable, Create, 0 };
</pre>

<li> Create an interface function that returns the <code>MuteInterface</code>
structure.  Use the <code>EffectInterfaceDll</code> macro to ensure the
correct calling convention is used and the function is exported.
<pre>
EffectInterfaceDll( void )
{
	return &amp;MuteInterface;
}
</pre>
</ol>

<h2><a name="Deriving the Plug-in Object">Deriving the Plug-in Object</a></h2>
<p>Deriving a plug-in object involves overriding or implementing
several functions.

<ol>
<li>
Since an effect plug-in is being created,
a new class must be derived from the <a href="#Effect Class">Gfx::Effect</a>
base class.  The <code>Name</code>, <code>Ability</code> and <code>Read</code>
functions must be implemented for effects.  Note that the <code>Seek</code>
function is implemented as well since muting is compatible with seeking
requirements.
<pre>
class Mute : public Effect
{
public:
	const wchar_t * gdecl	Name( void );
	unsigned int gdecl	Ability( void );
	int gdecl		Read( audio *data, int samples );
	bool gdecl		Seek( double time );
};
</pre>
<p>

<li> The <code>Name</code> function must return the same name stored in the table.
This can be done as follows:
<pre>
const wchar_t * gdecl Mute::Name( void )
{
	return MuteTable.name;
}
</pre>
<p>

<li> The <code>Ability</code> function must return the same abilities
stored in the table.  This can be done as follows:
<pre>
unsigned int gdecl Mute::Ability( void )
{
	return MuteTable.abilities;
}
</pre>

<li> The <code>Read</code> function processes the audio.  In this
case, it just zeros out the channels that can be modified.  We
still have to read the source in case only one channel of a
stereo file is to be muted, so the other channel will contain
valid audio data.  Note that for mono files (<code>channels == 1</code>),
no reading would be necessary at all, but this optimization has not
be added.

<pre>
int gdecl Mute::Read( audio *dest, int samples )
{
	// Read audio from source first
	samples = source-&gt;Read( dest, samples );

	// See what channels may be modified
	bool	doLeft = channel &amp; acfLeft,
		doRight = (channel &amp; acfLeft) &amp;&amp; channels &gt; 1;
	int	count = samples;

	// Mute samples
	while ( count-- )
	{
		if ( doLeft )
			dest[0] = 0;
		if ( doRight )
			dest[1] = 0;
		dest += channels;
	}

	return samples;
}
</pre>

<li> The <code>Seek</code> function just passes the call up the
chain.  Note that seeking is not allowed for effects that have
delay buffers or variable output that depends on multiple samples.

<pre>
bool gdecl Mute::Seek( double time )
{
	return source-&gt;Seek( time );
}
</pre>

</ol>

<p>The plug-in code is complete and ready for compiling and testing.
See the <a href="#Building">Compiling, Installing, and Testing</a>
section for more information.

<h2><a name="Additional Examples">Additional Examples</a></h2>

<p>For more detailed examples, refer to SampleEffect, SampleVisual,
and SampleFile included with this SDK in the
<code>gwplugin\examples</code> folder.

<p>Note: Samples were written using a tabstop of 4.

<div class="in">
<h3>SampleEffect</h3>
<p>This example includes an invert effect, which turns
a waveform upside down, and a volume effect, which changes the
volume of a sound.  The volume plug-in demonstrates the use of
a <a href="#Page">Page</a> interface.
<p><b>Files:</b><br>
<pre>	SampleEffect.cpp		// Source file
	SampleEffect.rc			// Resource file for dialog/page and icons
</pre>

<h3>SampleFile</h3>
<p>This example demonstrates a File Format plug-in for working with
simple RIFF Wave files.  Note that this plug-in does not fully support
all RIFF Wave files and must not be released in compiled form.  Use
it only as a model for creating plug-ins for other file types.
<p><b>Files:</b><br>
<pre>	SampleFile\SampleFile.cpp			// Source file
</pre>

<h3>FLACFile and DiamondWareFile</h3>
<p>These examples demonstrate <a href="http://flac.sourceforge.net">FLAC</a>,
<a href="http://www.diamondware.com">DiamondWare</a>, and
<a href="http://www.monkeysaudio.com">Monkey's Audio</a> file support for
GoldWave.  Modified compiled versions of these plug-ins must not be
released under these names.  The final plug-in name must be changed when
distributing modified versions so that the original plug-in included
with GoldWave is not overwritten.
<p><b>Files:</b><br>
<pre>	FLACFile\FLACFile.cpp				// Source file
	DiamondWareFile\DiamondWareFile.cpp		// Source file
	APEFile\APEFile.cpp				// Source file
</pre>

<h3>SampleVisual</h3>
<p>This example includes four visuals: elapsed time, waveform, mouse
event, and information.  The waveform visual includes a
<a href="#Page">Page</a> interface.
The mouse event visual demonstrates how to receive and handle events.
The information visual displays artist, copyright, album, and title
file information.
<p><b>Files:</b><br>
<pre>	SampleVisual\SampleVisual.cpp		// Source file
	SampleVisual\SampleVisual.rc		// Resource file for dialog/page
</pre>


</div>

<h1><a name="License">License</a></h1>

<p>The GoldWave Plug-in SDK is Copyright &copy; 2003-2009 GoldWave Inc.

<p>Redistribution and use in source and binary forms are permitted
given the following conditions:

<ul>
<li> Redistributions of modified source files that break or
damage compatibility with GoldWave software or other host programs
is strictly prohibited.

<li> Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

<li> Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

<li> The name of GoldWave Inc. must not be used to endorse or
promote products derived from this software without specific prior
written permission.
</ul>

This software is provided by GoldWave Inc. as is and any express or
implied warranties, including, but not limited to, the implied
warranties of merchantability and fitness for
a particular purpose are disclaimed.  In no event shall
GoldWave Inc. be liable for any direct, indirect, incidental, special,
exemplary, or consequential damages (including, but not limited to,
procurement of substitute goods or services; loss of use, data, or
profits; or business interruption) however caused and on any theory of
liability, whether in contract, strict liability, or tort (including
negligence or otherwise) arising in any way out of the use of this
software, even if advised of the possibility of such damage.


<h1><a name="FAQ">Frequently Asked Questions</a></h1>

<dl>
<dt>Is this SDK open?
<dd>No.  The SDK cannot be openly modified because it may break
compatibility with GoldWave or other host programs.  The header files
must not be modified, but the SDK can be freely redistributed.
Suggestions for improving the SDK are welcome.
<p>

<dt>Are there any fees or royalties?
<dd>No.
<p>

<dt>Is there an official licensing agreement?
<dd>See <a href="#License">License</a>.
You are free to create and distribute your own plug-ins using
whatever method you like.  The only restriction is that if you publically
redistribute them, then you must test them thoroughly
to ensure compatibility with GoldWave and that
it conforms
to this SDK as closely as possible.  You should mention what version
of GoldWave is required to run the plug-in.
<p>

<dt>Can I sell my plug-ins?
<dd>You are free to distribute the plug-ins you create at any cost and
in any way you like.  You cannot use the GoldWave trademark
to promote your plug-ins or imply that GoldWave Inc. developed or supports the
plug-ins.  You must ensure that you provide accurate ordering
information so that potential customers do not contact GoldWave Inc.
to purchase the plug-ins and they do not contact you to purchase
a GoldWave license.  You must provide accurate contact
and support details so that users <b>do not</b> contact GoldWave Inc. for
technical support or help.
<p>

<dt>Why not use the DirectX Audio Plug-in Standard?
<dd>There is no such thing as a formal DirectX Audio Plug-in Standard.
Those are based on DirectShow filters.  DirectShow filters
are complicated and require thousands of lines of
code to implement and rely on tens of thousands of lines of
support functions, base classes, and COM.  GoldWave plug-ins
rely only on a few header files.
<p>During beta testing of GoldWave, it was clear that DirectX Audio
Plug-ins are far from "standard".  Implementations vary from
one developer to the next, causing many inconsistencies and
potential instability in the host program.  Also, there is almost no
information that clearly explains how a host program
is supposed to use a DirectX Audio Plug-in.  Companies that
develop both host programs and plug-ins tend to design plug-ins
in such a way that they only work well within their own host
programs.
<p>

<dt>Why is Direct3D not supported for visuals?
<dd>Direct3D does not appear to offer any way of setting multiple
rendering contexts for multiple modules.  There can be only
one primary screen per application, so only one Direct3D visual
could work and all others would fail.
<p>

<dt>When must critical sections be used?
<dd>If your plug-in implements a <a href="#Page">Page</a> interface,
then a critical section is almost certainly necessary for
Effects and Visual plug-ins.  The <a href="#Page">Page</a> interface
operates on a different thread than the
<a href="#Effect::Read"><code>Effect::Read</code></a> and
<a href="#Visual::Draw"><code>Visual::Draw</code></a>
functions.  However, a host program must not call other
functions on different threads and it must not call other
functions when a thread is in the middle of a
<a href="#Effect::Read"><code>Read</code></a>/
<a href="#Visual::Draw"><code>Draw</code></a> call.
Only the <a href="#Page">Page</a>
interface and the <a href="#Effect::Read"><code>Read</code></a>
and <a href="#Visual::Draw"><code>Draw</code></a> calls
may occur simultaneously.
<p>

<dt>What is wrong with C++?
<dd>C++ (and C) portability is weak.  It lacks several
things that would make portability significantly easier.

<ul>
<li>
Some of the biggest problems are the variable size of int on
different platforms, the inability to make a variable a required
size, and byte ordering.  The following notation solves these problems:
<pre>
typedef bigendian int64:64;	// Stored as 64 bit Motorola order
typedef littleendian int64:64; 	// Stored as 64 bit Intel order
</pre>
<p>Bit field sizes are already allowed inside structures.  Why not
outside?
<p>

<li>
Class layout and structure packing is another problem.  Borland and
Microsoft do things differently.  Therefore a new keyword should be
added that would ensure class layout compatibility (sacrificing
speed if necessary):

<pre>
// Standard data/function/virtual table layout with 4 byte packing
stdclass x:4 { ... };
</pre>

<li>
Header files often need to have a header guard #if/#define/#end
to prevent multiple inclusion.  This means that the entire header
file has to be loaded and scanned to find the final #endif.  The compiler
could simply make note of what header files it has already parsed
and not include them again:

<pre>
#includeonce &lt;windows.h&gt;	// Skips the entire file if already included
</pre>

</ul>

<p>I expect they'll be building igloos in hell before the C++ standards
people adopt any of these ideas.
<p>

</dl>

<h1><a name="Glossary">Glossary</a></h1>

<p><b><a name="Bitrate">Bitrate</a></b> - The average number of
bits pers second required to store audio data.

<p><b><a name="Host Program">Host Program</a></b> - A program which
manages and uses <a href="#Plug-in">plug-ins</a>, such as GoldWave.

<p><b><a name="Plug-in">Plug-in</a></b> - An object created within an
external dynamic link library
module or shared library which adds new functionality to a
<a href="#Host Program">host program</a>.

<p><b><a name="Plug-in Module">Plug-in Module</a></b> - An external dynamic
link library module or shared library that contains one or more
plug-ins.

<p><b><a name="Sample">Sample</a></b> - Amplitude value or values for
all channels at a given instant in
time.  For a mono file, a sample is a single
<a href="#audio Type">audio</a> value.  For stereo, a sample is a
pair of <a href="#audio Type">audio</a> values.  This document uses
the term <i>sample</i> to refer to a group of amplitudes for all channels rather
than one amplitude for a single channel.

<p><b><a name="Sampling Rate">Sampling Rate</a></b> - The number of
samples per second at which the audio was recorded.

</body>
</html>


<!--
<div class="in">
<p><b>Declaration</b><br>
<pre>

</pre>

<p><b>Purpose</b><br>
<p><table align="center" border="1" width="75%" cellpadding=3>
<tr><th align=left>Member</th><th align=left>Purpose</th></tr>

<tr>
<td valign=top>
	<code></code>
</td>
<td>

</td>
</tr>
</table>
</div>



<pre style="border:thin solid;padding:10px 10px 10px 10px">
</pre>
-->

